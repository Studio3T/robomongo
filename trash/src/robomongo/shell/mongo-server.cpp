#include "mongo/base/string_data.h"
namespace mongo {
struct JSFile{ const char* name; const StringData& source; };
namespace JSFiles{
const StringData _jscode_raw_servers = 
"_parsePath = function() {\n" 
"var dbpath = \"\";\n" 
"for( var i = 0; i < arguments.length; ++i )\n" 
"if ( arguments[ i ] == \"--dbpath\" )\n" 
"dbpath = arguments[ i + 1 ];\n" 
"\n" 
"if ( dbpath == \"\" )\n" 
"throw \"No dbpath specified\";\n" 
"\n" 
"return dbpath;\n" 
"}\n" 
"\n" 
"_parsePort = function() {\n" 
"var port = \"\";\n" 
"for( var i = 0; i < arguments.length; ++i )\n" 
"if ( arguments[ i ] == \"--port\" )\n" 
"port = arguments[ i + 1 ];\n" 
"\n" 
"if ( port == \"\" )\n" 
"throw \"No port specified\";\n" 
"return port;\n" 
"}\n" 
"\n" 
"connectionURLTheSame = function( a , b ){\n" 
"\n" 
"if ( a == b )\n" 
"return true;\n" 
"\n" 
"if ( ! a || ! b )\n" 
"return false;\n" 
"\n" 
"if( a.host ) return connectionURLTheSame( a.host, b )\n" 
"if( b.host ) return connectionURLTheSame( a, b.host )\n" 
"\n" 
"if( a.name ) return connectionURLTheSame( a.name, b )\n" 
"if( b.name ) return connectionURLTheSame( a, b.name )\n" 
"\n" 
"if( a.indexOf( \"/\" ) < 0 && b.indexOf( \"/\" ) < 0 ){\n" 
"a = a.split( \":\" )\n" 
"b = b.split( \":\" )\n" 
"\n" 
"if( a.length != b.length ) return false\n" 
"\n" 
"if( a.length == 2 && a[1] != b[1] ) return false\n" 
"\n" 
"if( a[0] == \"localhost\" || a[0] == \"127.0.0.1\" ) a[0] = getHostName()\n" 
"if( b[0] == \"localhost\" || b[0] == \"127.0.0.1\" ) b[0] = getHostName()\n" 
"\n" 
"return a[0] == b[0]\n" 
"}\n" 
"else {\n" 
"var a0 = a.split( \"/\" )[0]\n" 
"var b0 = b.split( \"/\" )[0]\n" 
"return a0 == b0\n" 
"}\n" 
"}\n" 
"\n" 
"assert( connectionURLTheSame( \"foo\" , \"foo\" ) )\n" 
"assert( ! connectionURLTheSame( \"foo\" , \"bar\" ) )\n" 
"\n" 
"assert( connectionURLTheSame( \"foo/a,b\" , \"foo/b,a\" ) )\n" 
"assert( ! connectionURLTheSame( \"foo/a,b\" , \"bar/a,b\" ) )\n" 
"\n" 
"createMongoArgs = function( binaryName , args ){\n" 
"var fullArgs = [ binaryName ];\n" 
"\n" 
"if ( args.length == 1 && isObject( args[0] ) ){\n" 
"var o = args[0];\n" 
"for ( var k in o ){\n" 
"if ( o.hasOwnProperty(k) ){\n" 
"if ( k == \"v\" && isNumber( o[k] ) ){\n" 
"var n = o[k];\n" 
"if ( n > 0 ){\n" 
"if ( n > 10 ) n = 10;\n" 
"var temp = \"-\";\n" 
"while ( n-- > 0 ) temp += \"v\";\n" 
"fullArgs.push( temp );\n" 
"}\n" 
"}\n" 
"else {\n" 
"fullArgs.push( \"--\" + k );\n" 
"if ( o[k] != \"\" )\n" 
"fullArgs.push( \"\" + o[k] );\n" 
"}\n" 
"}\n" 
"}\n" 
"}\n" 
"else {\n" 
"for ( var i=0; i<args.length; i++ )\n" 
"fullArgs.push( args[i] )\n" 
"}\n" 
"\n" 
"return fullArgs;\n" 
"}\n" 
"\n" 
"\n" 
"MongoRunner = function(){}\n" 
"\n" 
"MongoRunner.dataDir = \"/data/db\"\n" 
"MongoRunner.dataPath = \"/data/db/\"\n" 
"MongoRunner.usedPortMap = {}\n" 
"\n" 
"MongoRunner.VersionSub = function(regex, version) {\n" 
"this.regex = regex;\n" 
"this.version = version;\n" 
"}\n" 
"\n" 
"// These patterns allow substituting the binary versions used for each\n" 
"// version string to support the dev/stable MongoDB release cycle.\n" 
"MongoRunner.binVersionSubs = [ new MongoRunner.VersionSub(/^latest$/, \"\"),\n" 
"new MongoRunner.VersionSub(/^last-stable$/, \"2.2\"),\n" 
"new MongoRunner.VersionSub(/^oldest-supported$/, \"1.8\"),\n" 
"// Latest unstable and next stable are effectively the\n" 
"// same release\n" 
"new MongoRunner.VersionSub(/^2\\.3(\\..*){0,1}/, \"\"),\n" 
"new MongoRunner.VersionSub(/^2\\.4(\\..*){0,1}/, \"\") ];\n" 
"\n" 
"MongoRunner.getBinVersionFor = function(version) {\n" 
"\n" 
"// If this is a version iterator, iterate the version via toString()\n" 
"if (version instanceof MongoRunner.versionIterator.iterator) {\n" 
"version = version.toString();\n" 
"}\n" 
"\n" 
"// No version set means we use no suffix, this is *different* from \"latest\"\n" 
"// since latest may be mapped to a different version.\n" 
"if (version == null) version = \"\";\n" 
"version = version.trim();\n" 
"if (version === \"\") return \"\";\n" 
"\n" 
"// See if this version is affected by version substitutions\n" 
"for (var i = 0; i < MongoRunner.binVersionSubs.length; i++) {\n" 
"var sub = MongoRunner.binVersionSubs[i];\n" 
"if (sub.regex.test(version)) {\n" 
"version = sub.version;\n" 
"}\n" 
"}\n" 
"\n" 
"return version;\n" 
"}\n" 
"\n" 
"MongoRunner.areBinVersionsTheSame = function(versionA, versionB) {\n" 
"\n" 
"versionA = MongoRunner.getBinVersionFor(versionA);\n" 
"versionB = MongoRunner.getBinVersionFor(versionB);\n" 
"\n" 
"if (versionA === \"\" || versionB === \"\") {\n" 
"return versionA === versionB;\n" 
"}\n" 
"\n" 
"return versionA.startsWith(versionB) ||\n" 
"versionB.startsWith(versionA);\n" 
"}\n" 
"\n" 
"MongoRunner.logicalOptions = { runId : true,\n" 
"pathOpts : true,\n" 
"remember : true,\n" 
"noRemember : true,\n" 
"appendOptions : true,\n" 
"restart : true,\n" 
"noCleanData : true,\n" 
"cleanData : true,\n" 
"startClean : true,\n" 
"forceLock : true,\n" 
"useLogFiles : true,\n" 
"useHostName : true,\n" 
"useHostname : true,\n" 
"noReplSet : true,\n" 
"forgetPort : true,\n" 
"arbiter : true,\n" 
"noJournalPrealloc : true,\n" 
"noJournal : true,\n" 
"binVersion : true,\n" 
"waitForConnect : true }\n" 
"\n" 
"MongoRunner.toRealPath = function( path, pathOpts ){\n" 
"\n" 
"// Replace all $pathOptions with actual values\n" 
"pathOpts = pathOpts || {}\n" 
"path = path.replace( /\\$dataPath/g, MongoRunner.dataPath )\n" 
"path = path.replace( /\\$dataDir/g, MongoRunner.dataDir )\n" 
"for( key in pathOpts ){\n" 
"path = path.replace( RegExp( \"\\\\$\" + RegExp.escape(key), \"g\" ), pathOpts[ key ] )\n" 
"}\n" 
"\n" 
"// Relative path\n" 
"if( ! path.startsWith( \"/\" ) ){\n" 
"if( path != \"\" && ! path.endsWith( \"/\" ) )\n" 
"path += \"/\"\n" 
"\n" 
"path = MongoRunner.dataPath + path\n" 
"}\n" 
"\n" 
"return path\n" 
"\n" 
"}\n" 
"\n" 
"MongoRunner.toRealDir = function( path, pathOpts ){\n" 
"\n" 
"path = MongoRunner.toRealPath( path, pathOpts )\n" 
"\n" 
"if( path.endsWith( \"/\" ) )\n" 
"path = path.substring( 0, path.length - 1 )\n" 
"\n" 
"return path\n" 
"}\n" 
"\n" 
"MongoRunner.toRealFile = MongoRunner.toRealDir\n" 
"\n" 
"MongoRunner.nextOpenPort = function(){\n" 
"\n" 
"var i = 0;\n" 
"while( MongoRunner.usedPortMap[ \"\" + ( 27000 + i ) ] ) i++;\n" 
"MongoRunner.usedPortMap[ \"\" + ( 27000 + i ) ] = true\n" 
"\n" 
"return 27000 + i\n" 
"\n" 
"}\n" 
"\n" 
"/**\n" 
"* Returns an iterator object which yields successive versions on toString(), starting from a\n" 
"* random initial position, from an array of versions.\n" 
"*\n" 
"* If passed a single version string or an already-existing version iterator, just returns the\n" 
"* object itself, since it will yield correctly on toString()\n" 
"*\n" 
"* @param {Array.<String>}|{String}|{versionIterator}\n" 
"*/\n" 
"MongoRunner.versionIterator = function( arr, isRandom ){\n" 
"\n" 
"// If this isn't an array of versions, or is already an iterator, just use it\n" 
"if( typeof arr == \"string\" ) return arr\n" 
"if( arr.isVersionIterator ) return arr\n" 
"\n" 
"if (isRandom == undefined) isRandom = false;\n" 
"\n" 
"// Starting pos\n" 
"var i = isRandom ? parseInt( Random.rand() * arr.length ) : 0;\n" 
"\n" 
"return new MongoRunner.versionIterator.iterator(i, arr);\n" 
"}\n" 
"\n" 
"MongoRunner.versionIterator.iterator = function(i, arr) {\n" 
"\n" 
"this.toString = function() {\n" 
"i = ( i + 1 ) % arr.length\n" 
"print( \"Returning next version : \" + i +\n" 
"\" (\" + arr[i] + \") from \" + tojson( arr ) + \"...\" );\n" 
"return arr[ i ]\n" 
"}\n" 
"\n" 
"this.isVersionIterator = true;\n" 
"\n" 
"}\n" 
"\n" 
"/**\n" 
"* Converts the args object by pairing all keys with their value and appending\n" 
"* dash-dash (--) to the keys. The only exception to this rule are keys that\n" 
"* are defined in MongoRunner.logicalOptions, of which they will be ignored.\n" 
"*\n" 
"* @param {string} binaryName\n" 
"* @param {Object} args\n" 
"*\n" 
"* @return {Array.<String>} an array of parameter strings that can be passed\n" 
"*   to the binary.\n" 
"*/\n" 
"MongoRunner.arrOptions = function( binaryName , args ){\n" 
"\n" 
"var fullArgs = [ \"\" ]\n" 
"\n" 
"if ( isObject( args ) || ( args.length == 1 && isObject( args[0] ) ) ){\n" 
"\n" 
"var o = isObject( args ) ? args : args[0]\n" 
"\n" 
"// If we've specified a particular binary version, use that\n" 
"if( o.binVersion && o.binVersion != \"latest\" && o.binVersion != \"\" )\n" 
"binaryName += \"-\" + o.binVersion\n" 
"\n" 
"// Manage legacy options\n" 
"var isValidOptionForBinary = function( option, value ){\n" 
"\n" 
"if( ! o.binVersion ) return true\n" 
"\n" 
"// Version 1.x options\n" 
"if( o.binVersion.startsWith( \"1.\" ) ){\n" 
"\n" 
"return [ \"nopreallocj\" ].indexOf( option ) < 0\n" 
"}\n" 
"\n" 
"return true\n" 
"}\n" 
"\n" 
"for ( var k in o ){\n" 
"\n" 
"// Make sure our logical option should be added to the array of options\n" 
"if( ! o.hasOwnProperty( k ) ||\n" 
"k in MongoRunner.logicalOptions ||\n" 
"! isValidOptionForBinary( k, o[k] ) ) continue\n" 
"\n" 
"if ( ( k == \"v\" || k == \"verbose\" ) && isNumber( o[k] ) ){\n" 
"var n = o[k]\n" 
"if ( n > 0 ){\n" 
"if ( n > 10 ) n = 10\n" 
"var temp = \"-\"\n" 
"while ( n-- > 0 ) temp += \"v\"\n" 
"fullArgs.push( temp )\n" 
"}\n" 
"}\n" 
"else {\n" 
"if( o[k] == undefined || o[k] == null ) continue\n" 
"fullArgs.push( \"--\" + k )\n" 
"if ( o[k] != \"\" )\n" 
"fullArgs.push( \"\" + o[k] )\n" 
"}\n" 
"}\n" 
"}\n" 
"else {\n" 
"for ( var i=0; i<args.length; i++ )\n" 
"fullArgs.push( args[i] )\n" 
"}\n" 
"\n" 
"fullArgs[ 0 ] = binaryName\n" 
"return fullArgs\n" 
"}\n" 
"\n" 
"MongoRunner.arrToOpts = function( arr ){\n" 
"\n" 
"var opts = {}\n" 
"for( var i = 1; i < arr.length; i++ ){\n" 
"if( arr[i].startsWith( \"-\" ) ){\n" 
"var opt = arr[i].replace( /^-/, \"\" ).replace( /^-/, \"\" )\n" 
"\n" 
"if( arr.length > i + 1 && ! arr[ i + 1 ].startsWith( \"-\" ) ){\n" 
"opts[ opt ] = arr[ i + 1 ]\n" 
"i++\n" 
"}\n" 
"else{\n" 
"opts[ opt ] = \"\"\n" 
"}\n" 
"\n" 
"if( opt.replace( /v/g, \"\" ) == \"\" ){\n" 
"opts[ \"verbose\" ] = opt.length\n" 
"}\n" 
"}\n" 
"}\n" 
"\n" 
"return opts\n" 
"}\n" 
"\n" 
"MongoRunner.savedOptions = {}\n" 
"\n" 
"MongoRunner.mongoOptions = function( opts ){\n" 
"\n" 
"// Don't remember waitForConnect\n" 
"var waitForConnect = opts.waitForConnect;\n" 
"delete opts.waitForConnect;\n" 
"\n" 
"// If we're a mongo object\n" 
"if( opts.getDB ){\n" 
"opts = { restart : opts.runId }\n" 
"}\n" 
"\n" 
"// Initialize and create a copy of the opts\n" 
"opts = Object.merge( opts || {}, {} )\n" 
"\n" 
"if( ! opts.restart ) opts.restart = false\n" 
"\n" 
"// RunId can come from a number of places\n" 
"// If restart is passed as an old connection\n" 
"if( opts.restart && opts.restart.getDB ){\n" 
"opts.runId = opts.restart.runId\n" 
"opts.restart = true\n" 
"}\n" 
"// If it's the runId itself\n" 
"else if( isObject( opts.restart ) ){\n" 
"opts.runId = opts.restart\n" 
"opts.restart = true\n" 
"}\n" 
"\n" 
"if( isObject( opts.remember ) ){\n" 
"opts.runId = opts.remember\n" 
"opts.remember = true\n" 
"}\n" 
"else if( opts.remember == undefined ){\n" 
"// Remember by default if we're restarting\n" 
"opts.remember = opts.restart\n" 
"}\n" 
"\n" 
"// If we passed in restart : <conn> or runId : <conn>\n" 
"if( isObject( opts.runId ) && opts.runId.runId ) opts.runId = opts.runId.runId\n" 
"\n" 
"if( opts.restart && opts.remember ) opts = Object.merge( MongoRunner.savedOptions[ opts.runId ], opts )\n" 
"\n" 
"// Create a new runId\n" 
"opts.runId = opts.runId || ObjectId()\n" 
"\n" 
"// Save the port if required\n" 
"if( ! opts.forgetPort ) opts.port = opts.port || MongoRunner.nextOpenPort()\n" 
"\n" 
"var shouldRemember = ( ! opts.restart && ! opts.noRemember ) || ( opts.restart && opts.appendOptions )\n" 
"\n" 
"// Normalize and get the binary version to use\n" 
"opts.binVersion = MongoRunner.getBinVersionFor(opts.binVersion);\n" 
"\n" 
"if ( shouldRemember ){\n" 
"MongoRunner.savedOptions[ opts.runId ] = Object.merge( opts, {} )\n" 
"}\n" 
"\n" 
"// Default for waitForConnect is true\n" 
"if (waitForConnect == undefined || waitForConnect == null) opts.waitForConnect = true;\n" 
"\n" 
"opts.port = opts.port || MongoRunner.nextOpenPort()\n" 
"MongoRunner.usedPortMap[ \"\" + parseInt( opts.port ) ] = true\n" 
"\n" 
"opts.pathOpts = Object.merge( opts.pathOpts || {}, { port : \"\" + opts.port, runId : \"\" + opts.runId } )\n" 
"\n" 
"return opts\n" 
"}\n" 
"\n" 
"/**\n" 
"* @option {object} opts\n" 
"*\n" 
"*   {\n" 
"*     dbpath {string}\n" 
"*     useLogFiles {boolean}: use with logFile option.\n" 
"*     logFile {string}: path to the log file. If not specified and useLogFiles\n" 
"*       is true, automatically creates a log file inside dbpath.\n" 
"*     noJournalPrealloc {boolean}\n" 
"*     noJournal {boolean}\n" 
"*     keyFile\n" 
"*     replSet\n" 
"*     oplogSize\n" 
"*   }\n" 
"*/\n" 
"MongoRunner.mongodOptions = function( opts ){\n" 
"\n" 
"opts = MongoRunner.mongoOptions( opts )\n" 
"\n" 
"opts.dbpath = MongoRunner.toRealDir( opts.dbpath || \"$dataDir/mongod-$port\",\n" 
"opts.pathOpts )\n" 
"\n" 
"opts.pathOpts = Object.merge( opts.pathOpts, { dbpath : opts.dbpath } )\n" 
"\n" 
"if( ! opts.logFile && opts.useLogFiles ){\n" 
"opts.logFile = opts.dbpath + \"/mongod.log\"\n" 
"}\n" 
"else if( opts.logFile ){\n" 
"opts.logFile = MongoRunner.toRealFile( opts.logFile, opts.pathOpts )\n" 
"}\n" 
"\n" 
"if( jsTestOptions().noJournalPrealloc || opts.noJournalPrealloc )\n" 
"opts.nopreallocj = \"\"\n" 
"\n" 
"if( jsTestOptions().noJournal || opts.noJournal )\n" 
"opts.nojournal = \"\"\n" 
"\n" 
"if( jsTestOptions().keyFile && !opts.keyFile) {\n" 
"opts.keyFile = jsTestOptions().keyFile\n" 
"}\n" 
"\n" 
"if( opts.noReplSet ) opts.replSet = null\n" 
"if( opts.arbiter ) opts.oplogSize = 1\n" 
"\n" 
"return opts\n" 
"}\n" 
"\n" 
"MongoRunner.mongosOptions = function( opts ){\n" 
"\n" 
"opts = MongoRunner.mongoOptions( opts )\n" 
"\n" 
"// Normalize configdb option to be host string if currently a host\n" 
"if( opts.configdb && opts.configdb.getDB ){\n" 
"opts.configdb = opts.configdb.host\n" 
"}\n" 
"\n" 
"opts.pathOpts = Object.merge( opts.pathOpts,\n" 
"{ configdb : opts.configdb.replace( /:|,/g, \"-\" ) } )\n" 
"\n" 
"if( ! opts.logFile && opts.useLogFiles ){\n" 
"opts.logFile = MongoRunner.toRealFile( \"$dataDir/mongos-$configdb-$port.log\",\n" 
"opts.pathOpts )\n" 
"}\n" 
"else if( opts.logFile ){\n" 
"opts.logFile = MongoRunner.toRealFile( opts.logFile, opts.pathOpts )\n" 
"}\n" 
"\n" 
"if( jsTestOptions().keyFile && !opts.keyFile) {\n" 
"opts.keyFile = jsTestOptions().keyFile\n" 
"}\n" 
"\n" 
"return opts\n" 
"}\n" 
"\n" 
"/**\n" 
"* Starts a mongod instance.\n" 
"*\n" 
"* @param {Object} opts\n" 
"*\n" 
"*   {\n" 
"*     useHostName {boolean}: Uses hostname of machine if true\n" 
"*     forceLock {boolean}: Deletes the lock file if set to true\n" 
"*     dbpath {string}: location of db files\n" 
"*     cleanData {boolean}: Removes all files in dbpath if true\n" 
"*     startClean {boolean}: same as cleanData\n" 
"*     noCleanData {boolean}: Do not clean files (cleanData takes priority)\n" 
"*\n" 
"*     @see MongoRunner.mongodOptions for other options\n" 
"*   }\n" 
"*\n" 
"* @return {Mongo} connection object to the started mongod instance.\n" 
"*\n" 
"* @see MongoRunner.arrOptions\n" 
"*/\n" 
"MongoRunner.runMongod = function( opts ){\n" 
"\n" 
"opts = opts || {}\n" 
"var useHostName = false;\n" 
"var runId = null;\n" 
"var waitForConnect = true;\n" 
"\n" 
"if( isObject( opts ) ) {\n" 
"\n" 
"opts = MongoRunner.mongodOptions( opts )\n" 
"\n" 
"useHostName = opts.useHostName || opts.useHostname;\n" 
"runId = opts.runId;\n" 
"waitForConnect = opts.waitForConnect;\n" 
"\n" 
"if( opts.forceLock ) removeFile( opts.dbpath + \"/mongod.lock\" )\n" 
"if( ( opts.cleanData || opts.startClean ) || ( ! opts.restart && ! opts.noCleanData ) ){\n" 
"print( \"Resetting db path '\" + opts.dbpath + \"'\" )\n" 
"resetDbpath( opts.dbpath )\n" 
"}\n" 
"\n" 
"opts = MongoRunner.arrOptions( \"mongod\", opts )\n" 
"}\n" 
"\n" 
"var mongod = MongoRunner.startWithArgs(opts, waitForConnect);\n" 
"if (!waitForConnect) mongos = {};\n" 
"if (!mongod) return null;\n" 
"\n" 
"mongod.commandLine = MongoRunner.arrToOpts( opts )\n" 
"mongod.name = (useHostName ? getHostName() : \"localhost\") + \":\" + mongod.commandLine.port\n" 
"mongod.host = mongod.name\n" 
"mongod.port = parseInt( mongod.commandLine.port )\n" 
"mongod.runId = runId || ObjectId()\n" 
"mongod.savedOptions = MongoRunner.savedOptions[ mongod.runId ]\n" 
"\n" 
"return mongod\n" 
"}\n" 
"\n" 
"MongoRunner.runMongos = function( opts ){\n" 
"\n" 
"opts = opts || {}\n" 
"var useHostName = false;\n" 
"var runId = null;\n" 
"var waitForConnect = true;\n" 
"\n" 
"if( isObject( opts ) ) {\n" 
"\n" 
"opts = MongoRunner.mongosOptions( opts )\n" 
"\n" 
"useHostName = opts.useHostName || opts.useHostname;\n" 
"runId = opts.runId;\n" 
"waitForConnect = opts.waitForConnect;\n" 
"\n" 
"opts = MongoRunner.arrOptions( \"mongos\", opts )\n" 
"}\n" 
"\n" 
"var mongos = MongoRunner.startWithArgs(opts, waitForConnect);\n" 
"if (!waitForConnect) mongos = {};\n" 
"if (!mongos) return null;\n" 
"\n" 
"mongos.commandLine = MongoRunner.arrToOpts( opts )\n" 
"mongos.name = (useHostName ? getHostName() : \"localhost\") + \":\" + mongos.commandLine.port\n" 
"mongos.host = mongos.name\n" 
"mongos.port = parseInt( mongos.commandLine.port )\n" 
"mongos.runId = runId || ObjectId()\n" 
"mongos.savedOptions = MongoRunner.savedOptions[ mongos.runId ]\n" 
"\n" 
"return mongos\n" 
"}\n" 
"\n" 
"/**\n" 
"* Kills a mongod process.\n" 
"*\n" 
"* @param {number} port the port of the process to kill\n" 
"* @param {number} signal The signal number to use for killing\n" 
"* @param {Object} opts Additional options. Format:\n" 
"*    {\n" 
"*      auth: {\n" 
"*        user {string}: admin user name\n" 
"*        pwd {string}: admin password\n" 
"*      }\n" 
"*    }\n" 
"*\n" 
"* Note: The auth option is required in a authenticated mongod running in Windows since\n" 
"*  it uses the shutdown command, which requires admin credentials.\n" 
"*/\n" 
"MongoRunner.stopMongod = function( port, signal, opts ){\n" 
"\n" 
"if( ! port ) {\n" 
"print( \"Cannot stop mongo process \" + port )\n" 
"return\n" 
"}\n" 
"\n" 
"signal = signal || 15\n" 
"\n" 
"if( port.port )\n" 
"port = parseInt( port.port )\n" 
"\n" 
"if( port instanceof ObjectId ){\n" 
"var opts = MongoRunner.savedOptions( port )\n" 
"if( opts ) port = parseInt( opts.port )\n" 
"}\n" 
"\n" 
"var exitCode = stopMongod( parseInt( port ), parseInt( signal ), opts )\n" 
"\n" 
"delete MongoRunner.usedPortMap[ \"\" + parseInt( port ) ]\n" 
"\n" 
"return exitCode\n" 
"}\n" 
"\n" 
"MongoRunner.stopMongos = MongoRunner.stopMongod\n" 
"\n" 
"MongoRunner.isStopped = function( port ){\n" 
"\n" 
"if( ! port ) {\n" 
"print( \"Cannot detect if process \" + port + \" is stopped.\" )\n" 
"return\n" 
"}\n" 
"\n" 
"if( port.port )\n" 
"port = parseInt( port.port )\n" 
"\n" 
"if( port instanceof ObjectId ){\n" 
"var opts = MongoRunner.savedOptions( port )\n" 
"if( opts ) port = parseInt( opts.port )\n" 
"}\n" 
"\n" 
"return MongoRunner.usedPortMap[ \"\" + parseInt( port ) ] ? false : true\n" 
"}\n" 
"\n" 
"startMongodTest = function (port, dirname, restart, extraOptions ) {\n" 
"if (!port)\n" 
"port = MongoRunner.nextOpenPort();\n" 
"var f = startMongodEmpty;\n" 
"if (restart)\n" 
"f = startMongodNoReset;\n" 
"if (!dirname)\n" 
"dirname = \"\" + port; // e.g., data/db/27000\n" 
"\n" 
"var useHostname = false;\n" 
"if (extraOptions) {\n" 
"useHostname = extraOptions.useHostname;\n" 
"delete extraOptions.useHostname;\n" 
"}\n" 
"\n" 
"\n" 
"var options =\n" 
"{\n" 
"port: port,\n" 
"dbpath: \"/data/db/\" + dirname,\n" 
"noprealloc: \"\",\n" 
"smallfiles: \"\",\n" 
"oplogSize: \"40\",\n" 
"nohttpinterface: \"\"\n" 
"};\n" 
"\n" 
"if( jsTestOptions().noJournal ) options[\"nojournal\"] = \"\"\n" 
"if( jsTestOptions().noJournalPrealloc ) options[\"nopreallocj\"] = \"\"\n" 
"if( jsTestOptions().auth ) options[\"auth\"] = \"\"\n" 
"if( jsTestOptions().keyFile && (!extraOptions || !extraOptions['keyFile']) ) options['keyFile'] = jsTestOptions().keyFile\n" 
"\n" 
"if ( extraOptions )\n" 
"Object.extend( options , extraOptions );\n" 
"\n" 
"var conn = f.apply(null, [ options ] );\n" 
"\n" 
"conn.name = (useHostname ? getHostName() : \"localhost\") + \":\" + port;\n" 
"\n" 
"if (options['auth'] || options['keyFile']) {\n" 
"if (!this.shardsvr && !options.replSet) {\n" 
"jsTest.addAuth(conn);\n" 
"}\n" 
"jsTest.authenticate(conn);\n" 
"}\n" 
"return conn;\n" 
"}\n" 
"\n" 
"// Start a mongod instance and return a 'Mongo' object connected to it.\n" 
"// This function's arguments are passed as command line arguments to mongod.\n" 
"// The specified 'dbpath' is cleared if it exists, created if not.\n" 
"// var conn = startMongodEmpty(\"--port\", 30000, \"--dbpath\", \"asdf\");\n" 
"startMongodEmpty = function () {\n" 
"var args = createMongoArgs(\"mongod\", arguments);\n" 
"\n" 
"var dbpath = _parsePath.apply(null, args);\n" 
"resetDbpath(dbpath);\n" 
"\n" 
"return startMongoProgram.apply(null, args);\n" 
"}\n" 
"startMongod = function () {\n" 
"print(\"startMongod WARNING DELETES DATA DIRECTORY THIS IS FOR TESTING ONLY\");\n" 
"return startMongodEmpty.apply(null, arguments);\n" 
"}\n" 
"startMongodNoReset = function(){\n" 
"var args = createMongoArgs( \"mongod\" , arguments );\n" 
"return startMongoProgram.apply( null, args );\n" 
"}\n" 
"\n" 
"startMongos = function(args){\n" 
"return MongoRunner.runMongos(args);\n" 
"}\n" 
"\n" 
"/**\n" 
"* Start a mongo process with a particular argument array.  If we aren't waiting for connect,\n" 
"* return null.\n" 
"*/\n" 
"MongoRunner.startWithArgs = function(argArray, waitForConnect) {\n" 
"\n" 
"var port = _parsePort.apply(null, argArray);\n" 
"\n" 
"// Enable test commands.\n" 
"// TODO: Make there only be one codepath for starting mongo processes\n" 
"var programName = argArray[0];\n" 
"if (jsTest.options().enableTestCommands && (programName.endsWith('mongod') || programName.endsWith('mongos'))) {\n" 
"argArray.push.apply(argArray, ['--setParameter', 'enableTestCommands=1']);\n" 
"}\n" 
"\n" 
"var pid = _startMongoProgram.apply(null, argArray);\n" 
"\n" 
"var conn = null;\n" 
"if (waitForConnect) {\n" 
"assert.soon( function() {\n" 
"try {\n" 
"conn = new Mongo(\"127.0.0.1:\" + port);\n" 
"return true;\n" 
"} catch( e ) {\n" 
"if (!checkProgram(pid)) {\n" 
"\n" 
"print(\"Could not start mongo program at \" + port + \", process ended\")\n" 
"\n" 
"// Break out\n" 
"return true;\n" 
"}\n" 
"}\n" 
"return false;\n" 
"}, \"unable to connect to mongo program on port \" + port, 600 * 1000);\n" 
"}\n" 
"\n" 
"return conn;\n" 
"}\n" 
"\n" 
"/**\n" 
"* DEPRECATED\n" 
"*\n" 
"* Start mongod or mongos and return a Mongo() object connected to there.\n" 
"* This function's first argument is \"mongod\" or \"mongos\" program name, \\\n" 
"* and subsequent arguments to this function are passed as\n" 
"* command line arguments to the program.\n" 
"*/\n" 
"startMongoProgram = function(){\n" 
"var port = _parsePort.apply( null, arguments );\n" 
"\n" 
"// Enable test commands.\n" 
"// TODO: Make this work better with multi-version testing so that we can support\n" 
"// enabling this on 2.4 when testing 2.6\n" 
"var args = argumentsToArray( arguments );\n" 
"var programName = args[0];\n" 
"if (jsTest.options().enableTestCommands && (programName.endsWith('mongod') || programName.endsWith('mongos'))) {\n" 
"args.push.apply(args, ['--setParameter', 'enableTestCommands=1']);\n" 
"}\n" 
"\n" 
"var pid = _startMongoProgram.apply( null, args );\n" 
"\n" 
"var m;\n" 
"assert.soon\n" 
"( function() {\n" 
"try {\n" 
"m = new Mongo( \"127.0.0.1:\" + port );\n" 
"return true;\n" 
"} catch( e ) {\n" 
"if (!checkProgram(pid)) {\n" 
"\n" 
"print(\"Could not start mongo program at \" + port + \", process ended\")\n" 
"\n" 
"// Break out\n" 
"m = null;\n" 
"return true;\n" 
"}\n" 
"}\n" 
"return false;\n" 
"}, \"unable to connect to mongo program on port \" + port, 600 * 1000 );\n" 
"\n" 
"return m;\n" 
"}\n" 
"\n" 
"runMongoProgram = function() {\n" 
"var args = argumentsToArray( arguments );\n" 
"if ( jsTestOptions().auth ) {\n" 
"var progName = args[0];\n" 
"args = args.slice(1);\n" 
"args.unshift( progName, '-u', jsTestOptions().adminUser,\n" 
"'-p', jsTestOptions().adminPassword );\n" 
"}\n" 
"return _runMongoProgram.apply( null, args );\n" 
"}\n" 
"\n" 
"// Start a mongo program instance.  This function's first argument is the\n" 
"// program name, and subsequent arguments to this function are passed as\n" 
"// command line arguments to the program.  Returns pid of the spawned program.\n" 
"startMongoProgramNoConnect = function() {\n" 
"var args = argumentsToArray( arguments );\n" 
"if ( jsTestOptions().auth ) {\n" 
"var progName = args[0];\n" 
"args = args.slice(1);\n" 
"args.unshift(progName, '-u', jsTestOptions().adminUser,\n" 
"'-p', jsTestOptions().adminPassword,\n" 
"'--authenticationMechanism', DB.prototype._defaultAuthenticationMechanism);\n" 
"}\n" 
"return _startMongoProgram.apply( null, args );\n" 
"}\n" 
"\n" 
"myPort = function() {\n" 
"var m = db.getMongo();\n" 
"if ( m.host.match( /:/ ) )\n" 
"return m.host.match( /:(.*)/ )[ 1 ];\n" 
"else\n" 
"return 27017;\n" 
"}\n" 
;
extern const JSFile servers;
const JSFile servers = { "src/mongo/shell/servers.js", _jscode_raw_servers };
const StringData _jscode_raw_shardingtest = 
"/**\n" 
"* Starts up a sharded cluster with the given specifications. The cluster\n" 
"* will be fully operational after the execution of this constructor function.\n" 
"*\n" 
"* @param {Object} testName Contains the key value pair for the cluster\n" 
"*   configuration. Accepted keys are:\n" 
"*\n" 
"*   {\n" 
"*     name {string}: name for this test\n" 
"*     verbose {number}: the verbosity for the mongos\n" 
"*     keyFile {string}: the location of the keyFile\n" 
"*     chunksize {number}:\n" 
"*     nopreallocj {boolean|number}:\n" 
"*\n" 
"*     mongos {number|Object|Array.<Object>}: number of mongos or mongos\n" 
"*       configuration object(s)(*). @see MongoRunner.runMongos\n" 
"*\n" 
"*     rs {Object|Array.<Object>}: replica set configuration object. Can\n" 
"*       contain:\n" 
"*       {\n" 
"*         nodes {number}: number of replica members. Defaults to 3.\n" 
"*         For other options, @see ReplSetTest#start\n" 
"*       }\n" 
"*\n" 
"*     shards {number|Object|Array.<Object>}: number of shards or shard\n" 
"*       configuration object(s)(*). @see MongoRunner.runMongod\n" 
"*\n" 
"*     config {number|Object|Array.<Object>}: number of config server or\n" 
"*       config server configuration object(s)(*). The presence of this field\n" 
"*       implies other.separateConfig = true, and if has 3 or more members,\n" 
"*       implies other.sync = true. @see MongoRunner.runMongod\n" 
"*\n" 
"*     (*) There are two ways For multiple configuration objects.\n" 
"*       (1) Using the object format. Example:\n" 
"*\n" 
"*           { d0: { verbose: 5 }, d1: { auth: '' }, rs2: { oplogsize: 10 }}\n" 
"*\n" 
"*           In this format, d = mongod, s = mongos & c = config servers\n" 
"*\n" 
"*       (2) Using the array format. Example:\n" 
"*\n" 
"*           [{ verbose: 5 }, { auth: '' }]\n" 
"*\n" 
"*       Note: you can only have single server shards for array format.\n" 
"*\n" 
"*     other: {\n" 
"*       nopreallocj: same as above\n" 
"*       rs: same as above\n" 
"*       chunksize: same as above\n" 
"*\n" 
"*       shardOptions {Object}: same as the shards property above.\n" 
"*          Can be used to specify options that are common all shards.\n" 
"*\n" 
"*       sync {boolean}: Use SyncClusterConnection, and readies\n" 
"*          3 config servers.\n" 
"*       separateConfig {boolean}: if false, recycle one of the running mongod\n" 
"*          as a config server. The config property can override this. False by\n" 
"*          default.\n" 
"*       configOptions {Object}: same as the config property above.\n" 
"*          Can be used to specify options that are common all config servers.\n" 
"*       mongosOptions {Object}: same as the mongos property above.\n" 
"*          Can be used to specify options that are common all mongos.\n" 
"*\n" 
"*       // replica Set only:\n" 
"*       rsOptions {Object}: same as the rs property above. Can be used to\n" 
"*         specify options that are common all replica members.\n" 
"*       useHostname {boolean}: if true, use hostname of machine,\n" 
"*         otherwise use localhost\n" 
"*       numReplicas {number}\n" 
"*     }\n" 
"*   }\n" 
"*\n" 
"* Member variables:\n" 
"* s {Mongo} - connection to the first mongos\n" 
"* s0, s1, ... {Mongo} - connection to different mongos\n" 
"* rs0, rs1, ... {ReplSetTest} - test objects to replica sets\n" 
"* shard0, shard1, ... {Mongo} - connection to shards (not available for replica sets)\n" 
"* d0, d1, ... {Mongo} - same as shard0, shard1, ...\n" 
"* config0, config1, ... {Mongo} - connection to config servers\n" 
"* c0, c1, ... {Mongo} - same as config0, config1, ...\n" 
"*/\n" 
"ShardingTest = function( testName , numShards , verboseLevel , numMongos , otherParams ){\n" 
"\n" 
"this._startTime = new Date();\n" 
"\n" 
"// Check if testName is an object, if so, pull params from there\n" 
"var keyFile = undefined\n" 
"otherParams = Object.merge( otherParams || {}, {} )\n" 
"otherParams.extraOptions = otherParams.extraOptions || {}\n" 
"\n" 
"if( isObject( testName ) ){\n" 
"\n" 
"var params = Object.merge( testName, {} )\n" 
"\n" 
"testName = params.name || \"test\"\n" 
"\n" 
"otherParams = Object.merge( params.other || {}, {} )\n" 
"otherParams.extraOptions = otherParams.extraOptions || {}\n" 
"\n" 
"numShards = params.shards || 2\n" 
"verboseLevel = params.verbose || 0\n" 
"numMongos = params.mongos || 1\n" 
"\n" 
"keyFile = params.keyFile || otherParams.keyFile || otherParams.extraOptions.keyFile\n" 
"otherParams.nopreallocj = params.nopreallocj || otherParams.nopreallocj\n" 
"otherParams.rs = params.rs || ( params.other ? params.other.rs : undefined )\n" 
"otherParams.chunksize = params.chunksize || ( params.other ? params.other.chunksize : undefined )\n" 
"\n" 
"var tempCount = 0;\n" 
"\n" 
"// Allow specifying options like :\n" 
"// { mongos : [ { noprealloc : \"\" } ], config : [ { smallfiles : \"\" } ], shards : { rs : true, d : true } }\n" 
"if( Array.isArray( numShards ) ){\n" 
"for( var i = 0; i < numShards.length; i++ ){\n" 
"otherParams[ \"d\" + i ] = numShards[i];\n" 
"}\n" 
"\n" 
"numShards = numShards.length;\n" 
"}\n" 
"else if( isObject( numShards ) ){\n" 
"tempCount = 0;\n" 
"for( var i in numShards ) {\n" 
"otherParams[ i ] = numShards[i];\n" 
"tempCount++;\n" 
"}\n" 
"\n" 
"numShards = tempCount;\n" 
"}\n" 
"\n" 
"if( Array.isArray( numMongos ) ){\n" 
"for( var i = 0; i < numMongos.length; i++ ) {\n" 
"otherParams[ \"s\" + i ] = numMongos[i];\n" 
"}\n" 
"\n" 
"numMongos = numMongos.length;\n" 
"}\n" 
"else if( isObject( numMongos ) ){\n" 
"tempCount = 0;\n" 
"for( var i in numMongos ) {\n" 
"otherParams[ i ] = numMongos[i];\n" 
"tempCount++;\n" 
"}\n" 
"\n" 
"numMongos = tempCount;\n" 
"}\n" 
"\n" 
"if( Array.isArray( params.config ) ){\n" 
"for( var i = 0; i < params.config.length; i++ ){\n" 
"otherParams[ \"c\" + i ] = params.config[i];\n" 
"}\n" 
"\n" 
"// If we're specifying explicit config options, we need separate config servers\n" 
"otherParams.separateConfig = true;\n" 
"if( params.config.length == 3 ) otherParams.sync = true;\n" 
"else otherParams.sync = false;\n" 
"}\n" 
"else if( isObject( params.config ) ){\n" 
"tempCount = 0;\n" 
"for( var i in params.config ) {\n" 
"otherParams[ i ] = params.config[i];\n" 
"tempCount++;\n" 
"}\n" 
"\n" 
"// If we're specifying explicit config options, we need separate config servers\n" 
"otherParams.separateConfig = true;\n" 
"if( params.config.length == 3 ) otherParams.sync = true;\n" 
"else otherParams.sync = false;\n" 
"}\n" 
"else if( params.config && params.config == 3 ) {\n" 
"otherParams.separateConfig = otherParams.separateConfig || true;\n" 
"otherParams.sync = true;\n" 
"}\n" 
"}\n" 
"else {\n" 
"// Handle legacy stuff\n" 
"keyFile = otherParams.extraOptions.keyFile\n" 
"}\n" 
"\n" 
"this._testName = testName\n" 
"this._otherParams = otherParams\n" 
"\n" 
"var pathOpts = this.pathOpts = { testName : testName }\n" 
"\n" 
"var hasRS = false\n" 
"for( var k in otherParams ){\n" 
"if( k.startsWith( \"rs\" ) && otherParams[k] != undefined ){\n" 
"hasRS = true\n" 
"break\n" 
"}\n" 
"}\n" 
"\n" 
"if( hasRS ){\n" 
"otherParams.separateConfig = true\n" 
"otherParams.useHostname = otherParams.useHostname == undefined ? true : otherParams.useHostname\n" 
"}\n" 
"\n" 
"var localhost = otherParams.useHostname ? getHostName() : \"localhost\";\n" 
"\n" 
"this._alldbpaths = []\n" 
"this._connections = []\n" 
"this._shardServers = this._connections\n" 
"this._rs = []\n" 
"this._rsObjects = []\n" 
"\n" 
"for ( var i = 0; i < numShards; i++ ) {\n" 
"if( otherParams.rs || otherParams[\"rs\" + i] ){\n" 
"\n" 
"otherParams.separateConfig = true\n" 
"\n" 
"var setName = testName + \"-rs\" + i;\n" 
"\n" 
"rsDefaults = { useHostname : otherParams.useHostname,\n" 
"noJournalPrealloc : otherParams.nopreallocj,\n" 
"oplogSize : 40,\n" 
"pathOpts : Object.merge( pathOpts, { shard : i } )}\n" 
"\n" 
"rsDefaults = Object.merge( rsDefaults, ShardingTest.rsOptions || {} )\n" 
"rsDefaults = Object.merge( rsDefaults, otherParams.rs )\n" 
"rsDefaults = Object.merge( rsDefaults, otherParams.rsOptions )\n" 
"rsDefaults = Object.merge( rsDefaults, otherParams[\"rs\" + i] )\n" 
"rsDefaults.nodes = rsDefaults.nodes || otherParams.numReplicas\n" 
"\n" 
"var numReplicas = rsDefaults.nodes || 3\n" 
"delete rsDefaults.nodes\n" 
"\n" 
"print( \"Replica set test!\" )\n" 
"\n" 
"var rs = new ReplSetTest( { name : setName , nodes : numReplicas , startPort : 31100 + ( i * 100 ), useHostName : otherParams.useHostname, keyFile : keyFile, shardSvr : true } );\n" 
"this._rs[i] = { setName : setName , test : rs , nodes : rs.startSet( rsDefaults ) , url : rs.getURL() };\n" 
"rs.initiate();\n" 
"this[\"rs\" + i] = rs\n" 
"\n" 
"this._rsObjects[i] = rs\n" 
"\n" 
"this._alldbpaths.push( null )\n" 
"this._connections.push( null )\n" 
"}\n" 
"else {\n" 
"var options = { useHostname : otherParams.useHostname,\n" 
"noJournalPrealloc : otherParams.nopreallocj,\n" 
"port : 30000 + i,\n" 
"pathOpts : Object.merge( pathOpts, { shard : i } ),\n" 
"dbpath : \"$testName$shard\",\n" 
"keyFile : keyFile\n" 
"}\n" 
"\n" 
"options = Object.merge( options, ShardingTest.shardOptions || {} )\n" 
"\n" 
"if( otherParams.shardOptions && otherParams.shardOptions.binVersion ){\n" 
"otherParams.shardOptions.binVersion =\n" 
"MongoRunner.versionIterator( otherParams.shardOptions.binVersion )\n" 
"}\n" 
"\n" 
"options = Object.merge( options, otherParams.shardOptions )\n" 
"options = Object.merge( options, otherParams[\"d\" + i] )\n" 
"\n" 
"var conn = MongoRunner.runMongod( options );\n" 
"\n" 
"this._alldbpaths.push( testName +i )\n" 
"this._connections.push( conn );\n" 
"this[\"shard\" + i] = conn\n" 
"this[\"d\" + i] = conn\n" 
"\n" 
"this._rs[i] = null\n" 
"this._rsObjects[i] = null\n" 
"}\n" 
"}\n" 
"\n" 
"// Do replication on replica sets if required\n" 
"for ( var i = 0; i < numShards; i++ ){\n" 
"if( ! otherParams.rs && ! otherParams[\"rs\" + i] ) continue\n" 
"\n" 
"var rs = this._rs[i].test;\n" 
"\n" 
"rs.getMaster().getDB( \"admin\" ).foo.save( { x : 1 } )\n" 
"rs.awaitReplication();\n" 
"rs.awaitSecondaryNodes();\n" 
"\n" 
"var rsConn = new Mongo( rs.getURL() );\n" 
"rsConn.name = rs.getURL();\n" 
"this._connections[i] = rsConn\n" 
"this[\"shard\" + i] = rsConn\n" 
"rsConn.rs = rs\n" 
"}\n" 
"\n" 
"this._configServers = []\n" 
"this._configNames = []\n" 
"\n" 
"if ( otherParams.sync && ! otherParams.separateConfig && numShards < 3 )\n" 
"throw \"if you want sync, you need at least 3 servers\";\n" 
"\n" 
"for ( var i = 0; i < ( otherParams.sync ? 3 : 1 ) ; i++ ) {\n" 
"\n" 
"var conn = null\n" 
"\n" 
"if( otherParams.separateConfig ){\n" 
"\n" 
"var options = { useHostname : otherParams.useHostname,\n" 
"noJournalPrealloc : otherParams.nopreallocj,\n" 
"port : 29000 + i,\n" 
"pathOpts : Object.merge( pathOpts, { config : i } ),\n" 
"dbpath : \"$testName-config$config\",\n" 
"keyFile : keyFile,\n" 
"configsvr : \"\"\n" 
"}\n" 
"\n" 
"options = Object.merge( options, ShardingTest.configOptions || {} )\n" 
"\n" 
"if( otherParams.configOptions && otherParams.configOptions.binVersion ){\n" 
"otherParams.configOptions.binVersion =\n" 
"MongoRunner.versionIterator( otherParams.configOptions.binVersion )\n" 
"}\n" 
"\n" 
"options = Object.merge( options, otherParams.configOptions )\n" 
"options = Object.merge( options, otherParams[\"c\" + i] )\n" 
"\n" 
"var conn = MongoRunner.runMongod( options )\n" 
"\n" 
"// TODO:  Needed?\n" 
"this._alldbpaths.push( testName + \"-config\" + i )\n" 
"}\n" 
"else{\n" 
"conn = this[\"shard\" + i]\n" 
"}\n" 
"\n" 
"this._configServers.push( conn );\n" 
"this._configNames.push( conn.name )\n" 
"this[\"config\" + i] = conn\n" 
"this[\"c\" + i] = conn\n" 
"}\n" 
"\n" 
"printjson( this._configDB = this._configNames.join( \",\" ) )\n" 
"this._configConnection = new Mongo( this._configDB )\n" 
"print( \"ShardingTest \" + this._testName + \" :\\n\" + tojson( { config : this._configDB, shards : this._connections } ) );\n" 
"\n" 
"if ( numMongos == 0 && !otherParams.noChunkSize ) {\n" 
"if ( keyFile ) {\n" 
"throw \"Cannot set chunk size without any mongos when using auth\";\n" 
"} else {\n" 
"this._configConnection.getDB( \"config\" ).settings.insert(\n" 
"{ _id : \"chunksize\" , value : otherParams.chunksize || otherParams.chunkSize || 50 } );\n" 
"}\n" 
"}\n" 
"\n" 
"this._mongos = []\n" 
"this._mongoses = this._mongos\n" 
"for ( var i = 0; i < ( ( numMongos == 0 ? -1 : numMongos ) || 1 ); i++ ){\n" 
"\n" 
"var options = { useHostname : otherParams.useHostname,\n" 
"port : 31000 - i - 1,\n" 
"pathOpts : Object.merge( pathOpts, { mongos : i } ),\n" 
"configdb : this._configDB,\n" 
"verbose : verboseLevel || 0,\n" 
"keyFile : keyFile\n" 
"}\n" 
"if ( ! otherParams.noChunkSize ) {\n" 
"options.chunkSize = otherParams.chunksize || otherParams.chunkSize || 50;\n" 
"}\n" 
"\n" 
"options = Object.merge( options, ShardingTest.mongosOptions || {} )\n" 
"\n" 
"if( otherParams.mongosOptions && otherParams.mongosOptions.binVersion ){\n" 
"otherParams.mongosOptions.binVersion =\n" 
"MongoRunner.versionIterator( otherParams.mongosOptions.binVersion )\n" 
"}\n" 
"\n" 
"options = Object.merge( options, otherParams.mongosOptions )\n" 
"options = Object.merge( options, otherParams.extraOptions )\n" 
"options = Object.merge( options, otherParams[\"s\" + i] )\n" 
"\n" 
"var conn = MongoRunner.runMongos( options )\n" 
"\n" 
"this._mongos.push( conn );\n" 
"if ( i == 0 ) this.s = conn\n" 
"this[\"s\" + i] = conn\n" 
"}\n" 
"\n" 
"var admin = this.admin = this.s.getDB( \"admin\" );\n" 
"this.config = this.s.getDB( \"config\" );\n" 
"\n" 
"if ( ! otherParams.manualAddShard ){\n" 
"this._shardNames = []\n" 
"var shardNames = this._shardNames\n" 
"this._connections.forEach(\n" 
"function(z){\n" 
"var n = z.name;\n" 
"if ( ! n ){\n" 
"n = z.host;\n" 
"if ( ! n )\n" 
"n = z;\n" 
"}\n" 
"print( \"ShardingTest \" + this._testName + \" going to add shard : \" + n )\n" 
"x = admin.runCommand( { addshard : n } );\n" 
"printjson( x )\n" 
"assert( x.ok );\n" 
"shardNames.push( x.shardAdded )\n" 
"z.shardName = x.shardAdded\n" 
"}\n" 
");\n" 
"}\n" 
"\n" 
"if (jsTestOptions().keyFile && !keyFile) {\n" 
"jsTest.addAuth( this._configConnection );\n" 
"jsTest.authenticate( this._configConnection );\n" 
"jsTest.authenticateNodes( this._configServers );\n" 
"jsTest.authenticateNodes( this._mongos );\n" 
"}\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getRSEntry = function( setName ){\n" 
"for ( var i=0; i<this._rs.length; i++ )\n" 
"if ( this._rs[i].setName == setName )\n" 
"return this._rs[i];\n" 
"throw \"can't find rs: \" + setName;\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getConfigIndex = function( config ){\n" 
"\n" 
"// Assume config is a # if not a conn object\n" 
"if( ! isObject( config ) ) config = getHostName() + \":\" + config\n" 
"\n" 
"for( var i = 0; i < this._configServers.length; i++ ){\n" 
"if( connectionURLTheSame( this._configServers[i], config ) ) return i\n" 
"}\n" 
"\n" 
"return -1\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getDB = function( name ){\n" 
"return this.s.getDB( name );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getServerName = function( dbname ){\n" 
"var x = this.config.databases.findOne( { _id : \"\" + dbname } );\n" 
"if ( x )\n" 
"return x.primary;\n" 
"this.config.databases.find().forEach( printjson );\n" 
"throw \"couldn't find dbname: \" + dbname + \" total: \" + this.config.databases.count();\n" 
"}\n" 
"\n" 
"\n" 
"ShardingTest.prototype.getNonPrimaries = function( dbname ){\n" 
"var x = this.config.databases.findOne( { _id : dbname } );\n" 
"if ( ! x ){\n" 
"this.config.databases.find().forEach( printjson );\n" 
"throw \"couldn't find dbname: \" + dbname + \" total: \" + this.config.databases.count();\n" 
"}\n" 
"\n" 
"return this.config.shards.find( { _id : { $ne : x.primary } } ).map( function(z){ return z._id; } )\n" 
"}\n" 
"\n" 
"\n" 
"ShardingTest.prototype.getConnNames = function(){\n" 
"var names = [];\n" 
"for ( var i=0; i<this._connections.length; i++ ){\n" 
"names.push( this._connections[i].name );\n" 
"}\n" 
"return names;\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getServer = function( dbname ){\n" 
"var name = this.getServerName( dbname );\n" 
"\n" 
"var x = this.config.shards.findOne( { _id : name } );\n" 
"if ( x )\n" 
"name = x.host;\n" 
"\n" 
"var rsName = null;\n" 
"if ( name.indexOf( \"/\" ) > 0 )\n" 
"rsName = name.substring( 0 , name.indexOf( \"/\" ) );\n" 
"\n" 
"for ( var i=0; i<this._connections.length; i++ ){\n" 
"var c = this._connections[i];\n" 
"if ( connectionURLTheSame( name , c.name ) ||\n" 
"connectionURLTheSame( rsName , c.name ) )\n" 
"return c;\n" 
"}\n" 
"\n" 
"throw \"can't find server for: \" + dbname + \" name:\" + name;\n" 
"\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.normalize = function( x ){\n" 
"var z = this.config.shards.findOne( { host : x } );\n" 
"if ( z )\n" 
"return z._id;\n" 
"return x;\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getOther = function( one ){\n" 
"if ( this._connections.length < 2 )\n" 
"throw \"getOther only works with 2 servers\";\n" 
"\n" 
"if ( one._mongo )\n" 
"one = one._mongo\n" 
"\n" 
"for( var i = 0; i < this._connections.length; i++ ){\n" 
"if( this._connections[i] != one ) return this._connections[i]\n" 
"}\n" 
"\n" 
"return null\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getAnother = function( one ){\n" 
"if(this._connections.length < 2)\n" 
"throw \"getAnother() only works with multiple servers\";\n" 
"\n" 
"if ( one._mongo )\n" 
"one = one._mongo\n" 
"\n" 
"for(var i = 0; i < this._connections.length; i++){\n" 
"if(this._connections[i] == one)\n" 
"return this._connections[(i + 1) % this._connections.length];\n" 
"}\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getFirstOther = function( one ){\n" 
"for ( var i=0; i<this._connections.length; i++ ){\n" 
"if ( this._connections[i] != one )\n" 
"return this._connections[i];\n" 
"}\n" 
"throw \"impossible\";\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.stop = function(){\n" 
"for ( var i=0; i<this._mongos.length; i++ ){\n" 
"stopMongoProgram( 31000 - i - 1 );\n" 
"}\n" 
"for ( var i=0; i<this._connections.length; i++){\n" 
"stopMongod( 30000 + i );\n" 
"}\n" 
"if ( this._rs ){\n" 
"for ( var i=0; i<this._rs.length; i++ ){\n" 
"if( this._rs[i] ) this._rs[i].test.stopSet( 15 );\n" 
"}\n" 
"}\n" 
"if( this._otherParams.separateConfig ){\n" 
"for ( var i=0; i<this._configServers.length; i++ ){\n" 
"MongoRunner.stopMongod( this._configServers[i] )\n" 
"}\n" 
"}\n" 
"if ( this._alldbpaths ){\n" 
"for( i=0; i<this._alldbpaths.length; i++ ){\n" 
"resetDbpath( \"/data/db/\" + this._alldbpaths[i] );\n" 
"}\n" 
"}\n" 
"\n" 
"var timeMillis = new Date().getTime() - this._startTime.getTime();\n" 
"\n" 
"print('*** ShardingTest ' + this._testName + \" completed successfully in \" + ( timeMillis / 1000 ) + \" seconds ***\");\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.adminCommand = function(cmd){\n" 
"var res = this.admin.runCommand( cmd );\n" 
"if ( res && res.ok == 1 )\n" 
"return true;\n" 
"\n" 
"throw \"command \" + tojson( cmd ) + \" failed: \" + tojson( res );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype._rangeToString = function(r){\n" 
"return tojsononeline( r.min ) + \" -> \" + tojsononeline( r.max );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.printChangeLog = function(){\n" 
"var s = this;\n" 
"this.config.changelog.find().forEach(\n" 
"function(z){\n" 
"var msg = z.server + \"\\t\" + z.time + \"\\t\" + z.what;\n" 
"for ( i=z.what.length; i<15; i++ )\n" 
"msg += \" \";\n" 
"msg += \" \" + z.ns + \"\\t\";\n" 
"if ( z.what == \"split\" ){\n" 
"msg += s._rangeToString( z.details.before ) + \" -->> (\" + s._rangeToString( z.details.left ) + \"),(\" + s._rangeToString( z.details.right ) + \")\";\n" 
"}\n" 
"else if (z.what == \"multi-split\" ){\n" 
"msg += s._rangeToString( z.details.before ) + \"  -->> (\" + z.details.number + \"/\" + z.details.of + \" \" + s._rangeToString( z.details.chunk ) + \")\";\n" 
"}\n" 
"else {\n" 
"msg += tojsononeline( z.details );\n" 
"}\n" 
"\n" 
"print( \"ShardingTest \" + msg )\n" 
"}\n" 
");\n" 
"\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getChunksString = function( ns ){\n" 
"var q = {}\n" 
"if ( ns )\n" 
"q.ns = ns;\n" 
"\n" 
"var s = \"\";\n" 
"this.config.chunks.find( q ).sort( { ns : 1 , min : 1 } ).forEach(\n" 
"function(z){\n" 
"s +=  \"  \" + z._id + \"\\t\" + z.lastmod.t + \"|\" + z.lastmod.i + \"\\t\" + tojson(z.min) + \" -> \" + tojson(z.max) + \" \" + z.shard + \"  \" + z.ns + \"\\n\";\n" 
"}\n" 
");\n" 
"\n" 
"return s;\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.printChunks = function( ns ){\n" 
"print( \"ShardingTest \" + this.getChunksString( ns ) );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.printShardingStatus = function(){\n" 
"printShardingStatus( this.config );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.printCollectionInfo = function( ns , msg ){\n" 
"var out = \"\";\n" 
"if ( msg )\n" 
"out += msg + \"\\n\";\n" 
"out += \"sharding collection info: \" + ns + \"\\n\";\n" 
"for ( var i=0; i<this._connections.length; i++ ){\n" 
"var c = this._connections[i];\n" 
"out += \"  mongod \" + c + \" \" + tojson( c.getCollection( ns ).getShardVersion() , \" \" , true ) + \"\\n\";\n" 
"}\n" 
"for ( var i=0; i<this._mongos.length; i++ ){\n" 
"var c = this._mongos[i];\n" 
"out += \"  mongos \" + c + \" \" + tojson( c.getCollection( ns ).getShardVersion() , \" \" , true ) + \"\\n\";\n" 
"}\n" 
"\n" 
"out += this.getChunksString( ns );\n" 
"\n" 
"print( \"ShardingTest \" + out );\n" 
"}\n" 
"\n" 
"printShardingStatus = function( configDB , verbose ){\n" 
"if (configDB === undefined)\n" 
"configDB = db.getSisterDB('config')\n" 
"\n" 
"var version = configDB.getCollection( \"version\" ).findOne();\n" 
"if ( version == null ){\n" 
"print( \"printShardingStatus: this db does not have sharding enabled. be sure you are connecting to a mongos from the shell and not to a mongod.\" );\n" 
"return;\n" 
"}\n" 
"\n" 
"var raw = \"\";\n" 
"var output = function(s){\n" 
"raw += s + \"\\n\";\n" 
"}\n" 
"output( \"--- Sharding Status --- \" );\n" 
"output( \"  sharding version: \" + tojson( configDB.getCollection( \"version\" ).findOne() ) );\n" 
"\n" 
"output( \"  shards:\" );\n" 
"configDB.shards.find().sort( { _id : 1 } ).forEach(\n" 
"function(z){\n" 
"output( \"\\t\" + tojsononeline( z ) );\n" 
"}\n" 
");\n" 
"\n" 
"output( \"  databases:\" );\n" 
"configDB.databases.find().sort( { name : 1 } ).forEach(\n" 
"function(db){\n" 
"output( \"\\t\" + tojsononeline(db,\"\",true) );\n" 
"\n" 
"if (db.partitioned){\n" 
"configDB.collections.find( { _id : new RegExp( \"^\" +\n" 
"RegExp.escape(db._id) + \"\\\\.\" ) } ).\n" 
"sort( { _id : 1 } ).forEach( function( coll ){\n" 
"if ( coll.dropped == false ){\n" 
"output( \"\\t\\t\" + coll._id );\n" 
"output( \"\\t\\t\\tshard key: \" + tojson(coll.key) );\n" 
"output( \"\\t\\t\\tchunks:\" );\n" 
"\n" 
"res = configDB.chunks.group( { cond : { ns : coll._id } , key : { shard : 1 },\n" 
"reduce : function( doc , out ){ out.nChunks++; } , initial : { nChunks : 0 } } );\n" 
"var totalChunks = 0;\n" 
"res.forEach( function(z){\n" 
"totalChunks += z.nChunks;\n" 
"output( \"\\t\\t\\t\\t\" + z.shard + \"\\t\" + z.nChunks );\n" 
"} )\n" 
"\n" 
"if ( totalChunks < 20 || verbose ){\n" 
"configDB.chunks.find( { \"ns\" : coll._id } ).sort( { min : 1 } ).forEach(\n" 
"function(chunk){\n" 
"output( \"\\t\\t\\t\" + tojson( chunk.min ) + \" -->> \" + tojson( chunk.max ) +\n" 
"\" on : \" + chunk.shard + \" \" + tojson( chunk.lastmod ) + \" \" +\n" 
"( chunk.jumbo ? \"jumbo \" : \"\" ) );\n" 
"}\n" 
");\n" 
"}\n" 
"else {\n" 
"output( \"\\t\\t\\ttoo many chunks to print, use verbose if you want to force print\" );\n" 
"}\n" 
"\n" 
"configDB.tags.find( { ns : coll._id } ).sort( { min : 1 } ).forEach(\n" 
"function( tag ) {\n" 
"output( \"\\t\\t\\t tag: \" + tag.tag + \"  \" + tojson( tag.min ) + \" -->> \" + tojson( tag.max ) );\n" 
"}\n" 
")\n" 
"}\n" 
"}\n" 
")\n" 
"}\n" 
"}\n" 
");\n" 
"\n" 
"print( raw );\n" 
"}\n" 
"\n" 
"printShardingSizes = function(){\n" 
"configDB = db.getSisterDB('config')\n" 
"\n" 
"var version = configDB.getCollection( \"version\" ).findOne();\n" 
"if ( version == null ){\n" 
"print( \"printShardingSizes : not a shard db!\" );\n" 
"return;\n" 
"}\n" 
"\n" 
"var raw = \"\";\n" 
"var output = function(s){\n" 
"raw += s + \"\\n\";\n" 
"}\n" 
"output( \"--- Sharding Status --- \" );\n" 
"output( \"  sharding version: \" + tojson( configDB.getCollection( \"version\" ).findOne() ) );\n" 
"\n" 
"output( \"  shards:\" );\n" 
"var shards = {};\n" 
"configDB.shards.find().forEach(\n" 
"function(z){\n" 
"shards[z._id] = new Mongo(z.host);\n" 
"output( \"      \" + tojson(z) );\n" 
"}\n" 
");\n" 
"\n" 
"var saveDB = db;\n" 
"output( \"  databases:\" );\n" 
"configDB.databases.find().sort( { name : 1 } ).forEach(\n" 
"function(db){\n" 
"output( \"\\t\" + tojson(db,\"\",true) );\n" 
"\n" 
"if (db.partitioned){\n" 
"configDB.collections.find( { _id : new RegExp( \"^\" +\n" 
"RegExp.escape(db._id) + \"\\.\" ) } ).\n" 
"sort( { _id : 1 } ).forEach( function( coll ){\n" 
"output(\"\\t\\t\" + coll._id + \" chunks:\");\n" 
"configDB.chunks.find( { \"ns\" : coll._id } ).sort( { min : 1 } ).forEach(\n" 
"function(chunk){\n" 
"var mydb = shards[chunk.shard].getDB(db._id)\n" 
"var out = mydb.runCommand({dataSize: coll._id,\n" 
"keyPattern: coll.key,\n" 
"min: chunk.min,\n" 
"max: chunk.max });\n" 
"delete out.millis;\n" 
"delete out.ok;\n" 
"\n" 
"output( \"\\t\\t\\t\" + tojson( chunk.min ) + \" -->> \" + tojson( chunk.max ) +\n" 
"\" on : \" + chunk.shard + \" \" + tojson( out ) );\n" 
"\n" 
"}\n" 
");\n" 
"}\n" 
")\n" 
"}\n" 
"}\n" 
");\n" 
"\n" 
"print( raw );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.sync = function(){\n" 
"this.adminCommand( \"connpoolsync\" );\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.onNumShards = function( collName , dbName ){\n" 
"this.sync(); // we should sync since we're going directly to mongod here\n" 
"dbName = dbName || \"test\";\n" 
"var num=0;\n" 
"for ( var i=0; i<this._connections.length; i++ )\n" 
"if ( this._connections[i].getDB( dbName ).getCollection( collName ).count() > 0 )\n" 
"num++;\n" 
"return num;\n" 
"}\n" 
"\n" 
"\n" 
"ShardingTest.prototype.shardCounts = function( collName , dbName ){\n" 
"this.sync(); // we should sync since we're going directly to mongod here\n" 
"dbName = dbName || \"test\";\n" 
"var counts = {}\n" 
"for ( var i=0; i<this._connections.length; i++ )\n" 
"counts[i] = this._connections[i].getDB( dbName ).getCollection( collName ).count();\n" 
"return counts;\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.chunkCounts = function( collName , dbName ){\n" 
"dbName = dbName || \"test\";\n" 
"var x = {}\n" 
"\n" 
"this.config.shards.find().forEach(\n" 
"function(z){\n" 
"x[z._id] = 0;\n" 
"}\n" 
");\n" 
"\n" 
"this.config.chunks.find( { ns : dbName + \".\" + collName } ).forEach(\n" 
"function(z){\n" 
"if ( x[z.shard] )\n" 
"x[z.shard]++\n" 
"else\n" 
"x[z.shard] = 1;\n" 
"}\n" 
");\n" 
"return x;\n" 
"\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.chunkDiff = function( collName , dbName ){\n" 
"var c = this.chunkCounts( collName , dbName );\n" 
"var min = 100000000;\n" 
"var max = 0;\n" 
"for ( var s in c ){\n" 
"if ( c[s] < min )\n" 
"min = c[s];\n" 
"if ( c[s] > max )\n" 
"max = c[s];\n" 
"}\n" 
"print( \"ShardingTest input: \" + tojson( c ) + \" min: \" + min + \" max: \" + max  );\n" 
"return max - min;\n" 
"}\n" 
"\n" 
"// Waits up to one minute for the difference in chunks between the most loaded shard and least\n" 
"// loaded shard to be 0 or 1, indicating that the collection is well balanced.\n" 
"// This should only be called after creating a big enough chunk difference to trigger balancing.\n" 
"ShardingTest.prototype.awaitBalance = function( collName , dbName , timeToWait ) {\n" 
"timeToWait = timeToWait || 60000;\n" 
"var shardingTest = this;\n" 
"assert.soon( function() {\n" 
"var x = shardingTest.chunkDiff( collName , dbName );\n" 
"print( \"chunk diff: \" + x );\n" 
"return x < 2;\n" 
"} , \"no balance happened\", 60000 );\n" 
"\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.getShard = function( coll, query, includeEmpty ){\n" 
"var shards = this.getShards( coll, query, includeEmpty )\n" 
"assert.eq( shards.length, 1 )\n" 
"return shards[0]\n" 
"}\n" 
"\n" 
"// Returns the shards on which documents matching a particular query reside\n" 
"ShardingTest.prototype.getShards = function( coll, query, includeEmpty ){\n" 
"if( ! coll.getDB )\n" 
"coll = this.s.getCollection( coll )\n" 
"\n" 
"var explain = coll.find( query ).explain()\n" 
"var shards = []\n" 
"\n" 
"if( explain.shards ){\n" 
"\n" 
"for( var shardName in explain.shards ){\n" 
"for( var i = 0; i < explain.shards[shardName].length; i++ ){\n" 
"if( includeEmpty || ( explain.shards[shardName][i].n && explain.shards[shardName][i].n > 0 ) )\n" 
"shards.push( shardName )\n" 
"}\n" 
"}\n" 
"\n" 
"}\n" 
"\n" 
"for( var i = 0; i < shards.length; i++ ){\n" 
"for( var j = 0; j < this._connections.length; j++ ){\n" 
"if ( connectionURLTheSame(  this._connections[j] , shards[i] ) ){\n" 
"shards[i] = this._connections[j]\n" 
"break;\n" 
"}\n" 
"}\n" 
"}\n" 
"\n" 
"return shards\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.isSharded = function( collName ){\n" 
"\n" 
"var collName = \"\" + collName\n" 
"var dbName = undefined\n" 
"\n" 
"if( typeof collName.getCollectionNames == 'function' ){\n" 
"dbName = \"\" + collName\n" 
"collName = undefined\n" 
"}\n" 
"\n" 
"if( dbName ){\n" 
"var x = this.config.databases.findOne( { _id : dbname } )\n" 
"if( x ) return x.partitioned\n" 
"else return false\n" 
"}\n" 
"\n" 
"if( collName ){\n" 
"var x = this.config.collections.findOne( { _id : collName } )\n" 
"if( x ) return true\n" 
"else return false\n" 
"}\n" 
"\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.shardGo = function( collName , key , split , move , dbName ){\n" 
"\n" 
"split = ( split != false ? ( split || key ) : split )\n" 
"move = ( split != false && move != false ? ( move || split ) : false )\n" 
"\n" 
"if( collName.getDB )\n" 
"dbName = \"\" + collName.getDB()\n" 
"else dbName = dbName || \"test\";\n" 
"\n" 
"var c = dbName + \".\" + collName;\n" 
"if( collName.getDB )\n" 
"c = \"\" + collName\n" 
"\n" 
"var isEmpty = this.s.getCollection( c ).count() == 0\n" 
"\n" 
"if( ! this.isSharded( dbName ) )\n" 
"this.s.adminCommand( { enableSharding : dbName } )\n" 
"\n" 
"var result = this.s.adminCommand( { shardcollection : c , key : key } )\n" 
"if( ! result.ok ){\n" 
"printjson( result )\n" 
"assert( false )\n" 
"}\n" 
"\n" 
"if( split == false ) return\n" 
"\n" 
"result = this.s.adminCommand( { split : c , middle : split } );\n" 
"if( ! result.ok ){\n" 
"printjson( result )\n" 
"assert( false )\n" 
"}\n" 
"\n" 
"if( move == false ) return\n" 
"\n" 
"var result = null\n" 
"for( var i = 0; i < 5; i++ ){\n" 
"result = this.s.adminCommand( { movechunk : c , find : move , to : this.getOther( this.getServer( dbName ) ).name } );\n" 
"if( result.ok ) break;\n" 
"sleep( 5 * 1000 );\n" 
"}\n" 
"printjson( result )\n" 
"assert( result.ok )\n" 
"\n" 
"};\n" 
"\n" 
"ShardingTest.prototype.shardColl = ShardingTest.prototype.shardGo\n" 
"\n" 
"ShardingTest.prototype.setBalancer = function( balancer ){\n" 
"if( balancer || balancer == undefined ){\n" 
"this.config.settings.update( { _id: \"balancer\" }, { $set : { stopped: false } } , true )\n" 
"}\n" 
"else if( balancer == false ){\n" 
"this.config.settings.update( { _id: \"balancer\" }, { $set : { stopped: true } } , true )\n" 
"}\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.stopBalancer = function( timeout, interval ) {\n" 
"this.setBalancer( false )\n" 
"\n" 
"if( typeof db == \"undefined\" ) db = undefined\n" 
"var oldDB = db\n" 
"\n" 
"db = this.config\n" 
"sh.waitForBalancer( false, timeout, interval )\n" 
"db = oldDB\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.startBalancer = function( timeout, interval ) {\n" 
"this.setBalancer( true )\n" 
"\n" 
"if( typeof db == \"undefined\" ) db = undefined\n" 
"var oldDB = db\n" 
"\n" 
"db = this.config\n" 
"sh.waitForBalancer( true, timeout, interval )\n" 
"db = oldDB\n" 
"}\n" 
"\n" 
"ShardingTest.prototype.isAnyBalanceInFlight = function() {\n" 
"if ( this.config.locks.find({ _id : { $ne : \"balancer\" }, state : 2 }).count() > 0 )\n" 
"return true;\n" 
"\n" 
"var allCurrent = this.s.getDB( \"admin\" ).currentOp().inprog;\n" 
"for ( var i = 0; i < allCurrent.length; i++ ) {\n" 
"if ( allCurrent[i].desc &&\n" 
"allCurrent[i].desc.indexOf( \"cleanupOldData\" ) == 0 )\n" 
"return true;\n" 
"}\n" 
"return false;\n" 
"}\n" 
"\n" 
"/**\n" 
"* Kills the mongos with index n.\n" 
"*/\n" 
"ShardingTest.prototype.stopMongos = function(n) {\n" 
"MongoRunner.stopMongos(this['s' + n].port);\n" 
"};\n" 
"\n" 
"/**\n" 
"* Restarts a previously stopped mongos using the same parameter as before.\n" 
"*\n" 
"* Warning: Overwrites the old s (if n = 0) and sn member variables\n" 
"*/\n" 
"ShardingTest.prototype.restartMongos = function(n) {\n" 
"this.stopMongos(n);\n" 
"var newConn = MongoRunner.runMongos(this['s' + n].commandLine);\n" 
"\n" 
"this['s' + n] = newConn;\n" 
"if (n == 0) {\n" 
"this.s = newConn;\n" 
"}\n" 
"};\n" 
"\n" 
;
extern const JSFile shardingtest;
const JSFile shardingtest = { "src/mongo/shell/shardingtest.js", _jscode_raw_shardingtest };
const StringData _jscode_raw_servers_misc = 
"/**\n" 
"* Run a mongod process.\n" 
"*\n" 
"* After initializing a MongodRunner, you must call start() on it.\n" 
"* @param {int} port port to run db on, use allocatePorts(num) to requision\n" 
"* @param {string} dbpath path to use\n" 
"* @param {boolean} peer pass in false (DEPRECATED, was used for replica pair host)\n" 
"* @param {boolean} arbiter pass in false (DEPRECATED, was used for replica pair host)\n" 
"* @param {array} extraArgs other arguments for the command line\n" 
"* @param {object} options other options include no_bind to not bind_ip to 127.0.0.1\n" 
"*    (necessary for replica set testing)\n" 
"*/\n" 
"MongodRunner = function( port, dbpath, peer, arbiter, extraArgs, options ) {\n" 
"this.port_ = port;\n" 
"this.dbpath_ = dbpath;\n" 
"this.peer_ = peer;\n" 
"this.arbiter_ = arbiter;\n" 
"this.extraArgs_ = extraArgs;\n" 
"this.options_ = options ? options : {};\n" 
"};\n" 
"\n" 
"/**\n" 
"* Start this mongod process.\n" 
"*\n" 
"* @param {boolean} reuseData If the data directory should be left intact (default is to wipe it)\n" 
"*/\n" 
"MongodRunner.prototype.start = function( reuseData ) {\n" 
"var args = [];\n" 
"if ( reuseData ) {\n" 
"args.push( \"mongod\" );\n" 
"}\n" 
"args.push( \"--port\" );\n" 
"args.push( this.port_ );\n" 
"args.push( \"--dbpath\" );\n" 
"args.push( this.dbpath_ );\n" 
"args.push( \"--nohttpinterface\" );\n" 
"args.push( \"--noprealloc\" );\n" 
"args.push( \"--smallfiles\" );\n" 
"if (!this.options_.no_bind) {\n" 
"args.push( \"--bind_ip\" );\n" 
"args.push( \"127.0.0.1\" );\n" 
"}\n" 
"if ( this.extraArgs_ ) {\n" 
"args = args.concat( this.extraArgs_ );\n" 
"}\n" 
"removeFile( this.dbpath_ + \"/mongod.lock\" );\n" 
"if ( reuseData ) {\n" 
"return startMongoProgram.apply( null, args );\n" 
"} else {\n" 
"return startMongod.apply( null, args );\n" 
"}\n" 
"}\n" 
"\n" 
"MongodRunner.prototype.port = function() { return this.port_; }\n" 
"\n" 
"MongodRunner.prototype.toString = function() { return [ this.port_, this.dbpath_, this.peer_, this.arbiter_ ].toString(); }\n" 
"\n" 
"ToolTest = function( name, extraOptions ){\n" 
"this.name = name;\n" 
"this.options = extraOptions;\n" 
"this.port = allocatePorts(1)[0];\n" 
"this.baseName = \"jstests_tool_\" + name;\n" 
"this.root = \"/data/db/\" + this.baseName;\n" 
"this.dbpath = this.root + \"/\";\n" 
"this.ext = this.root + \"_external/\";\n" 
"this.extFile = this.root + \"_external/a\";\n" 
"resetDbpath( this.dbpath );\n" 
"resetDbpath( this.ext );\n" 
"}\n" 
"\n" 
"ToolTest.prototype.startDB = function( coll ){\n" 
"assert( ! this.m , \"db already running\" );\n" 
"\n" 
"var options = {port : this.port,\n" 
"dbpath : this.dbpath,\n" 
"nohttpinterface : \"\",\n" 
"noprealloc : \"\",\n" 
"smallfiles : \"\",\n" 
"bind_ip : \"127.0.0.1\"};\n" 
"\n" 
"Object.extend(options, this.options);\n" 
"\n" 
"this.m = startMongoProgram.apply(null, MongoRunner.arrOptions(\"mongod\", options));\n" 
"this.db = this.m.getDB( this.baseName );\n" 
"if ( coll )\n" 
"return this.db.getCollection( coll );\n" 
"return this.db;\n" 
"}\n" 
"\n" 
"ToolTest.prototype.stop = function(){\n" 
"if ( ! this.m )\n" 
"return;\n" 
"stopMongod( this.port );\n" 
"this.m = null;\n" 
"this.db = null;\n" 
"\n" 
"print('*** ' + this.name + \" completed successfully ***\");\n" 
"}\n" 
"\n" 
"ToolTest.prototype.runTool = function(){\n" 
"var a = [ \"mongo\" + arguments[0] ];\n" 
"\n" 
"var hasdbpath = false;\n" 
"\n" 
"for ( var i=1; i<arguments.length; i++ ){\n" 
"a.push( arguments[i] );\n" 
"if ( arguments[i] == \"--dbpath\" )\n" 
"hasdbpath = true;\n" 
"}\n" 
"\n" 
"if ( ! hasdbpath ){\n" 
"a.push( \"--host\" );\n" 
"a.push( \"127.0.0.1:\" + this.port );\n" 
"}\n" 
"\n" 
"return runMongoProgram.apply( null , a );\n" 
"}\n" 
"\n" 
"\n" 
"ReplTest = function( name, ports ){\n" 
"this.name = name;\n" 
"this.ports = ports || allocatePorts( 2 );\n" 
"}\n" 
"\n" 
"ReplTest.prototype.getPort = function( master ){\n" 
"if ( master )\n" 
"return this.ports[ 0 ];\n" 
"return this.ports[ 1 ]\n" 
"}\n" 
"\n" 
"ReplTest.prototype.getPath = function( master ){\n" 
"var p = \"/data/db/\" + this.name + \"-\";\n" 
"if ( master )\n" 
"p += \"master\";\n" 
"else\n" 
"p += \"slave\"\n" 
"return p;\n" 
"}\n" 
"\n" 
"ReplTest.prototype.getOptions = function( master , extra , putBinaryFirst, norepl ){\n" 
"\n" 
"if ( ! extra )\n" 
"extra = {};\n" 
"\n" 
"if ( ! extra.oplogSize )\n" 
"extra.oplogSize = \"40\";\n" 
"\n" 
"var a = []\n" 
"if ( putBinaryFirst )\n" 
"a.push( \"mongod\" )\n" 
"a.push( \"--nohttpinterface\", \"--noprealloc\", \"--bind_ip\" , \"127.0.0.1\" , \"--smallfiles\" );\n" 
"\n" 
"a.push( \"--port\" );\n" 
"a.push( this.getPort( master ) );\n" 
"\n" 
"a.push( \"--dbpath\" );\n" 
"a.push( this.getPath( master ) );\n" 
"\n" 
"if( jsTestOptions().noJournal ) a.push( \"--nojournal\" )\n" 
"if( jsTestOptions().noJournalPrealloc ) a.push( \"--nopreallocj\" )\n" 
"if( jsTestOptions().keyFile ) {\n" 
"a.push( \"--keyFile\" )\n" 
"a.push( jsTestOptions().keyFile )\n" 
"}\n" 
"\n" 
"if ( !norepl ) {\n" 
"if ( master ){\n" 
"a.push( \"--master\" );\n" 
"}\n" 
"else {\n" 
"a.push( \"--slave\" );\n" 
"a.push( \"--source\" );\n" 
"a.push( \"127.0.0.1:\" + this.ports[0] );\n" 
"}\n" 
"}\n" 
"\n" 
"for ( var k in extra ){\n" 
"var v = extra[k];\n" 
"if( k in MongoRunner.logicalOptions ) continue\n" 
"a.push( \"--\" + k );\n" 
"if ( v != null )\n" 
"a.push( v );\n" 
"}\n" 
"\n" 
"return a;\n" 
"}\n" 
"\n" 
"ReplTest.prototype.start = function( master , options , restart, norepl ){\n" 
"var lockFile = this.getPath( master ) + \"/mongod.lock\";\n" 
"removeFile( lockFile );\n" 
"var o = this.getOptions( master , options , restart, norepl );\n" 
"\n" 
"\n" 
"if (restart) {\n" 
"return startMongoProgram.apply(null, o);\n" 
"} else {\n" 
"var conn = startMongod.apply(null, o);\n" 
"if (jsTestOptions().keyFile || jsTestOptions().auth) {\n" 
"if (master) {\n" 
"jsTest.addAuth(conn);\n" 
"}\n" 
"jsTest.authenticate(conn);\n" 
"}\n" 
"return conn;\n" 
"}\n" 
"}\n" 
"\n" 
"ReplTest.prototype.stop = function( master , signal ){\n" 
"if ( arguments.length == 0 ){\n" 
"this.stop( true );\n" 
"this.stop( false );\n" 
"return;\n" 
"}\n" 
"\n" 
"print('*** ' + this.name + \" completed successfully ***\");\n" 
"return stopMongod( this.getPort( master ) , signal || 15 );\n" 
"}\n" 
"\n" 
"allocatePorts = function( n , startPort ) {\n" 
"var ret = [];\n" 
"var start = startPort || 31000;\n" 
"for( var i = start; i < start + n; ++i )\n" 
"ret.push( i );\n" 
"return ret;\n" 
"}\n" 
"\n" 
"\n" 
"SyncCCTest = function( testName , extraMongodOptions ){\n" 
"this._testName = testName;\n" 
"this._connections = [];\n" 
"\n" 
"for ( var i=0; i<3; i++ ){\n" 
"this._connections.push( startMongodTest( 30000 + i , testName + i , false, extraMongodOptions ) );\n" 
"}\n" 
"\n" 
"this.url = this._connections.map( function(z){ return z.name; } ).join( \",\" );\n" 
"this.conn = new Mongo( this.url );\n" 
"}\n" 
"\n" 
"SyncCCTest.prototype.stop = function(){\n" 
"for ( var i=0; i<this._connections.length; i++){\n" 
"stopMongod( 30000 + i );\n" 
"}\n" 
"\n" 
"print('*** ' + this._testName + \" completed successfully ***\");\n" 
"}\n" 
"\n" 
"SyncCCTest.prototype.checkHashes = function( dbname , msg ){\n" 
"var hashes = this._connections.map(\n" 
"function(z){\n" 
"return z.getDB( dbname ).runCommand( \"dbhash\" );\n" 
"}\n" 
");\n" 
"\n" 
"for ( var i=1; i<hashes.length; i++ ){\n" 
"assert.eq( hashes[0].md5 , hashes[i].md5 , \"checkHash on \" + dbname + \" \" + msg + \"\\n\" + tojson( hashes ) )\n" 
"}\n" 
"}\n" 
"\n" 
"SyncCCTest.prototype.tempKill = function( num ){\n" 
"num = num || 0;\n" 
"stopMongod( 30000 + num );\n" 
"}\n" 
"\n" 
"SyncCCTest.prototype.tempStart = function( num ){\n" 
"num = num || 0;\n" 
"this._connections[num] = startMongodTest( 30000 + num , this._testName + num , true );\n" 
"}\n" 
"\n" 
"\n" 
"function startParallelShell( jsCode, port ){\n" 
"var x;\n" 
"\n" 
"var args = [\"mongo\"];\n" 
"if (port) {\n" 
"args.push(\"--port\", port);\n" 
"}\n" 
"\n" 
"if (typeof(db) == \"object\") {\n" 
"jsCode = \"db = db.getSiblingDB('\" + db.getName() + \"');\" + jsCode;\n" 
"}\n" 
"\n" 
"if (TestData) {\n" 
"jsCode = \"TestData = \" + tojson(TestData) + \";\" + jsCode;\n" 
"}\n" 
"\n" 
"args.push(\"--eval\", jsCode);\n" 
"\n" 
"if (typeof db == \"object\") {\n" 
"// Must start connected to admin DB so auth works when running tests with auth.\n" 
"args.push(db.getMongo().host + \"/admin\");\n" 
"}\n" 
"\n" 
"x = startMongoProgramNoConnect.apply(null, args);\n" 
"return function(){\n" 
"waitProgram( x );\n" 
"};\n" 
"}\n" 
"\n" 
"var testingReplication = false;\n" 
"\n" 
"function skipIfTestingReplication(){\n" 
"if (testingReplication) {\n" 
"print(\"skipIfTestingReplication skipping\");\n" 
"quit(0);\n" 
"}\n" 
"}\n" 
;
extern const JSFile servers_misc;
const JSFile servers_misc = { "src/mongo/shell/servers_misc.js", _jscode_raw_servers_misc };
const StringData _jscode_raw_replsettest = 
"/**\n" 
"* Sets up a replica set. To make the set running, call {@link #startSet},\n" 
"* followed by {@link #initiate} (and optionally,\n" 
"* {@link #awaitSecondaryNodes} to block till the  set is fully operational).\n" 
"* Note that some of the replica start up parameters are not passed here,\n" 
"* but to the #startSet method.\n" 
"*\n" 
"* @param {Object} opts\n" 
"*\n" 
"*   {\n" 
"*     name {string}: name of this replica set. Default: 'testReplSet'\n" 
"*     host {string}: name of the host machine. Hostname will be used\n" 
"*        if not specified.\n" 
"*     useHostName {boolean}: if true, use hostname of machine,\n" 
"*        otherwise use localhost\n" 
"*     nodes {number|Object|Array.<Object>}: number of replicas. Default: 0.\n" 
"*        Can also be an Object (or Array).\n" 
"*        Format for Object:\n" 
"*          {\n" 
"*            <any string>: replica member option Object. @see MongoRunner.runMongod\n" 
"*            <any string2>: and so on...\n" 
"*          }\n" 
"*\n" 
"*        Format for Array:\n" 
"*           An array of replica member option Object. @see MongoRunner.runMongod\n" 
"*\n" 
"*        Note: For both formats, a special boolean property 'arbiter' can be\n" 
"*          specified to denote a member is an arbiter.\n" 
"*\n" 
"*     nodeOptions {Object}: Options to apply to all nodes in the replica set.\n" 
"*        Format for Object:\n" 
"*          { cmdline-param-with-no-arg : \"\",\n" 
"*            param-with-arg : arg }\n" 
"*        This turns into \"mongod --cmdline-param-with-no-arg --param-with-arg arg\"\n" 
"*\n" 
"*     oplogSize {number}: Default: 40\n" 
"*     useSeedList {boolean}: Use the connection string format of this set\n" 
"*        as the replica set name (overrides the name property). Default: false\n" 
"*     bridged {boolean}: Whether to set a mongobridge between replicas.\n" 
"*        Default: false\n" 
"*     keyFile {string}\n" 
"*     shardSvr {boolean}: Default: false\n" 
"*     startPort {number}: port offset to be used for each replica. Default: 31000\n" 
"*   }\n" 
"*\n" 
"* Member variables:\n" 
"* numNodes {number} - number of nodes\n" 
"* nodes {Array.<Mongo>} - connection to replica set members\n" 
"*/\n" 
"ReplSetTest = function( opts ){\n" 
"this.name  = opts.name || \"testReplSet\";\n" 
"this.useHostName = opts.useHostName == undefined ? true : opts.useHostName;\n" 
"this.host  = this.useHostName ? (opts.host || getHostName()) : 'localhost';\n" 
"this.numNodes = opts.nodes || 0;\n" 
"this.oplogSize = opts.oplogSize || 40;\n" 
"this.useSeedList = opts.useSeedList || false;\n" 
"this.bridged = opts.bridged || false;\n" 
"this.ports = [];\n" 
"this.keyFile = opts.keyFile\n" 
"this.shardSvr = opts.shardSvr || false;\n" 
"\n" 
"this.startPort = opts.startPort || 31000;\n" 
"\n" 
"this.nodeOptions = {}\n" 
"if( isObject( this.numNodes ) ){\n" 
"var len = 0\n" 
"for( var i in this.numNodes ){\n" 
"var options = this.nodeOptions[ \"n\" + len ] = Object.merge(opts.nodeOptions,\n" 
"this.numNodes[i]);\n" 
"if( i.startsWith( \"a\" ) ) options.arbiter = true;\n" 
"len++\n" 
"}\n" 
"this.numNodes = len\n" 
"}\n" 
"else if( Array.isArray( this.numNodes ) ){\n" 
"for( var i = 0; i < this.numNodes.length; i++ )\n" 
"this.nodeOptions[ \"n\" + i ] = Object.merge(opts.nodeOptions, this.numNodes[i]);\n" 
"this.numNodes = this.numNodes.length\n" 
"}\n" 
"else {\n" 
"for ( var i =0; i < this.numNodes; i++ )\n" 
"this.nodeOptions[ \"n\" + i ] = opts.nodeOptions;\n" 
"}\n" 
"\n" 
"if(this.bridged) {\n" 
"this.bridgePorts = [];\n" 
"\n" 
"var allPorts = allocatePorts( this.numNodes * 2 , this.startPort );\n" 
"for(var i=0; i < this.numNodes; i++) {\n" 
"this.ports[i] = allPorts[i*2];\n" 
"this.bridgePorts[i] = allPorts[i*2 + 1];\n" 
"}\n" 
"\n" 
"this.initBridges();\n" 
"}\n" 
"else {\n" 
"this.ports = allocatePorts( this.numNodes , this.startPort );\n" 
"}\n" 
"\n" 
"this.nodes = []\n" 
"this.initLiveNodes()\n" 
"\n" 
"Object.extend( this, ReplSetTest.Health )\n" 
"Object.extend( this, ReplSetTest.State )\n" 
"\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.initBridges = function() {\n" 
"for(var i=0; i<this.ports.length; i++) {\n" 
"startMongoProgram( \"mongobridge\", \"--port\", this.bridgePorts[i], \"--dest\", this.host + \":\" + this.ports[i] );\n" 
"}\n" 
"}\n" 
"\n" 
"// List of nodes as host:port strings.\n" 
"ReplSetTest.prototype.nodeList = function() {\n" 
"var list = [];\n" 
"for(var i=0; i<this.ports.length; i++) {\n" 
"list.push( this.host + \":\" + this.ports[i]);\n" 
"}\n" 
"\n" 
"return list;\n" 
"}\n" 
"\n" 
"// Here we store a reference to all reachable nodes.\n" 
"ReplSetTest.prototype.initLiveNodes = function() {\n" 
"this.liveNodes = { master: null, slaves: [] }\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getNodeId = function(node) {\n" 
"\n" 
"if( node.toFixed ) return parseInt( node )\n" 
"\n" 
"for( var i = 0; i < this.nodes.length; i++ ){\n" 
"if( this.nodes[i] == node ) return i\n" 
"}\n" 
"\n" 
"if( node instanceof ObjectId ){\n" 
"for( var i = 0; i < this.nodes.length; i++ ){\n" 
"if( this.nodes[i].runId == node ) return i\n" 
"}\n" 
"}\n" 
"\n" 
"if( node.nodeId ) return parseInt( node.nodeId )\n" 
"\n" 
"return undefined\n" 
"\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getPort = function( n ){\n" 
"\n" 
"n = this.getNodeId( n )\n" 
"\n" 
"print( \"ReplSetTest n: \" + n + \" ports: \" + tojson( this.ports ) + \"\\t\" + this.ports[n] + \" \" + typeof(n) );\n" 
"return this.ports[ n ];\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getPath = function( n ){\n" 
"\n" 
"if( n.host )\n" 
"n = this.getNodeId( n )\n" 
"\n" 
"var p = \"/data/db/\" + this.name + \"-\"+n;\n" 
"if ( ! this._alldbpaths )\n" 
"this._alldbpaths = [ p ];\n" 
"else\n" 
"this._alldbpaths.push( p );\n" 
"return p;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getReplSetConfig = function() {\n" 
"var cfg = {};\n" 
"\n" 
"cfg['_id']  = this.name;\n" 
"cfg.members = [];\n" 
"\n" 
"for(i=0; i<this.ports.length; i++) {\n" 
"member = {};\n" 
"member['_id']  = i;\n" 
"\n" 
"if(this.bridged)\n" 
"var port = this.bridgePorts[i];\n" 
"else\n" 
"var port = this.ports[i];\n" 
"\n" 
"member['host'] = this.host + \":\" + port;\n" 
"if( this.nodeOptions[ \"n\" + i ] && this.nodeOptions[ \"n\" + i ].arbiter )\n" 
"member['arbiterOnly'] = true\n" 
"\n" 
"cfg.members.push(member);\n" 
"}\n" 
"\n" 
"return cfg;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getURL = function(){\n" 
"var hosts = [];\n" 
"\n" 
"for(i=0; i<this.ports.length; i++) {\n" 
"\n" 
"// Don't include this node in the replica set list\n" 
"if(this.bridged && this.ports[i] == this.ports[n]) {\n" 
"continue;\n" 
"}\n" 
"\n" 
"var port;\n" 
"// Connect on the right port\n" 
"if(this.bridged) {\n" 
"port = this.bridgePorts[i];\n" 
"}\n" 
"else {\n" 
"port = this.ports[i];\n" 
"}\n" 
"\n" 
"var str = this.host + \":\" + port;\n" 
"hosts.push(str);\n" 
"}\n" 
"\n" 
"return this.name + \"/\" + hosts.join(\",\");\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getOptions = function( n , extra , putBinaryFirst ){\n" 
"\n" 
"if ( ! extra )\n" 
"extra = {};\n" 
"\n" 
"if ( ! extra.oplogSize )\n" 
"extra.oplogSize = this.oplogSize;\n" 
"\n" 
"var a = []\n" 
"\n" 
"\n" 
"if ( putBinaryFirst )\n" 
"a.push( \"mongod\" );\n" 
"\n" 
"if ( extra.noReplSet ) {\n" 
"delete extra.noReplSet;\n" 
"}\n" 
"else {\n" 
"a.push( \"--replSet\" );\n" 
"\n" 
"if( this.useSeedList ) {\n" 
"a.push( this.getURL() );\n" 
"}\n" 
"else {\n" 
"a.push( this.name );\n" 
"}\n" 
"}\n" 
"\n" 
"a.push( \"--noprealloc\", \"--smallfiles\" );\n" 
"\n" 
"a.push( \"--rest\" );\n" 
"\n" 
"a.push( \"--port\" );\n" 
"a.push( this.getPort( n ) );\n" 
"\n" 
"a.push( \"--dbpath\" );\n" 
"a.push( this.getPath( ( n.host ? this.getNodeId( n ) : n ) ) );\n" 
"\n" 
"if( this.keyFile ){\n" 
"a.push( \"--keyFile\" )\n" 
"a.push( keyFile )\n" 
"}\n" 
"\n" 
"if( jsTestOptions().noJournal ) a.push( \"--nojournal\" )\n" 
"if( jsTestOptions().noJournalPrealloc ) a.push( \"--nopreallocj\" )\n" 
"if( jsTestOptions().keyFile && !this.keyFile) {\n" 
"a.push( \"--keyFile\" )\n" 
"a.push( jsTestOptions().keyFile )\n" 
"}\n" 
"\n" 
"for ( var k in extra ){\n" 
"var v = extra[k];\n" 
"if( k in MongoRunner.logicalOptions ) continue\n" 
"a.push( \"--\" + k );\n" 
"if ( v != null ){\n" 
"if( v.replace ){\n" 
"v = v.replace(/\\$node/g, \"\" + ( n.host ? this.getNodeId( n ) : n ) )\n" 
"v = v.replace(/\\$set/g, this.name )\n" 
"v = v.replace(/\\$path/g, this.getPath( n ) )\n" 
"}\n" 
"a.push( v );\n" 
"}\n" 
"}\n" 
"\n" 
"return a;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.startSet = function( options ) {\n" 
"\n" 
"var nodes = [];\n" 
"print( \"ReplSetTest Starting Set\" );\n" 
"\n" 
"for( n = 0 ; n < this.ports.length; n++ ) {\n" 
"node = this.start(n, options)\n" 
"nodes.push(node);\n" 
"}\n" 
"\n" 
"this.nodes = nodes;\n" 
"return this.nodes;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.callIsMaster = function() {\n" 
"\n" 
"var master = null;\n" 
"this.initLiveNodes();\n" 
"\n" 
"for(var i=0; i<this.nodes.length; i++) {\n" 
"\n" 
"try {\n" 
"var n = this.nodes[i].getDB('admin').runCommand({ismaster:1});\n" 
"\n" 
"if(n['ismaster'] == true) {\n" 
"master = this.nodes[i]\n" 
"this.liveNodes.master = master\n" 
"}\n" 
"else {\n" 
"this.nodes[i].setSlaveOk();\n" 
"this.liveNodes.slaves.push(this.nodes[i]);\n" 
"}\n" 
"\n" 
"}\n" 
"catch(err) {\n" 
"print(\"ReplSetTest Could not call ismaster on node \" + i);\n" 
"}\n" 
"}\n" 
"\n" 
"return master || false;\n" 
"}\n" 
"\n" 
"ReplSetTest.awaitRSClientHosts = function( conn, host, hostOk, rs ) {\n" 
"var hostCount = host.length;\n" 
"if( hostCount ){\n" 
"for( var i = 0; i < hostCount; i++ ) {\n" 
"ReplSetTest.awaitRSClientHosts( conn, host[i], hostOk, rs );\n" 
"}\n" 
"return;\n" 
"}\n" 
"\n" 
"if( hostOk == undefined ) hostOk = { ok : true }\n" 
"if( host.host ) host = host.host\n" 
"if( rs && rs.getMaster ) rs = rs.name\n" 
"\n" 
"print( \"Awaiting \" + host + \" to be \" + tojson( hostOk ) + \" for \" + conn + \" (rs: \" + rs + \")\" )\n" 
"\n" 
"var tests = 0\n" 
"assert.soon( function() {\n" 
"var rsClientHosts = conn.getDB( \"admin\" ).runCommand( \"connPoolStats\" )[ \"replicaSets\" ]\n" 
"if( tests++ % 10 == 0 )\n" 
"printjson( rsClientHosts )\n" 
"\n" 
"for ( rsName in rsClientHosts ){\n" 
"if( rs && rs != rsName ) continue\n" 
"for ( var i = 0; i < rsClientHosts[rsName].hosts.length; i++ ){\n" 
"var clientHost = rsClientHosts[rsName].hosts[ i ];\n" 
"if( clientHost.addr != host ) continue\n" 
"\n" 
"// Check that *all* host properties are set correctly\n" 
"var propOk = true\n" 
"for( var prop in hostOk ){\n" 
"if ( isObject( hostOk[prop] )) {\n" 
"if ( !friendlyEqual( hostOk[prop], clientHost[prop] )){\n" 
"propOk = false;\n" 
"break;\n" 
"}\n" 
"}\n" 
"else if ( clientHost[prop] != hostOk[prop] ){\n" 
"propOk = false;\n" 
"break;\n" 
"}\n" 
"}\n" 
"\n" 
"if( propOk ) return true;\n" 
"\n" 
"}\n" 
"}\n" 
"return false;\n" 
"}, \"timed out waiting for replica set client to recognize hosts\",\n" 
"3 * 20 * 1000 /* ReplicaSetMonitorWatcher updates every 20s */ )\n" 
"\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.awaitSecondaryNodes = function( timeout ) {\n" 
"this.getMaster(); // Wait for a primary to be selected.\n" 
"var tmo = timeout || 60000;\n" 
"var replTest = this;\n" 
"assert.soon(\n" 
"function() {\n" 
"replTest.getMaster(); // Reload who the current slaves are.\n" 
"var slaves = replTest.liveNodes.slaves;\n" 
"var len = slaves.length;\n" 
"var ready = true;\n" 
"for(var i=0; i<len; i++) {\n" 
"var isMaster = slaves[i].getDB(\"admin\").runCommand({ismaster: 1});\n" 
"var arbiter = isMaster['arbiterOnly'] == undefined ? false : isMaster['arbiterOnly'];\n" 
"ready = ready && ( isMaster['secondary'] || arbiter );\n" 
"}\n" 
"return ready;\n" 
"}, \"Awaiting secondaries\", tmo);\n" 
"};\n" 
"\n" 
"ReplSetTest.prototype.getMaster = function( timeout ) {\n" 
"var tries = 0;\n" 
"var sleepTime = 500;\n" 
"var tmo = timeout || 60000;\n" 
"var master = null;\n" 
"\n" 
"master = jsTest.attempt({context: this, timeout: tmo, desc: \"Finding master\"}, this.callIsMaster);\n" 
"return master;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getPrimary = ReplSetTest.prototype.getMaster\n" 
"\n" 
"ReplSetTest.prototype.getSecondaries = function( timeout ){\n" 
"var master = this.getMaster( timeout )\n" 
"var secs = []\n" 
"for( var i = 0; i < this.nodes.length; i++ ){\n" 
"if( this.nodes[i] != master ){\n" 
"secs.push( this.nodes[i] )\n" 
"}\n" 
"}\n" 
"return secs\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getSecondary = function( timeout ){\n" 
"return this.getSecondaries( timeout )[0];\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.status = function( timeout ){\n" 
"var master = this.callIsMaster()\n" 
"if( ! master ) master = this.liveNodes.slaves[0]\n" 
"return master.getDB(\"admin\").runCommand({replSetGetStatus: 1})\n" 
"}\n" 
"\n" 
"// Add a node to the test set\n" 
"ReplSetTest.prototype.add = function( config ) {\n" 
"if(this.ports.length == 0) {\n" 
"var nextPort = allocatePorts( 1, this.startPort )[0];\n" 
"}\n" 
"else {\n" 
"var nextPort = this.ports[this.ports.length-1] + 1;\n" 
"}\n" 
"print(\"ReplSetTest Next port: \" + nextPort);\n" 
"this.ports.push(nextPort);\n" 
"printjson(this.ports);\n" 
"\n" 
"var nextId = this.nodes.length;\n" 
"printjson(this.nodes);\n" 
"print(\"ReplSetTest nextId:\" + nextId);\n" 
"var newNode = this.start( nextId );\n" 
"\n" 
"return newNode;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.remove = function( nodeId ) {\n" 
"nodeId = this.getNodeId( nodeId )\n" 
"this.nodes.splice( nodeId, 1 );\n" 
"this.ports.splice( nodeId, 1 );\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.initiate = function( cfg , initCmd , timeout ) {\n" 
"var master  = this.nodes[0].getDB(\"admin\");\n" 
"var config  = cfg || this.getReplSetConfig();\n" 
"var cmd     = {};\n" 
"var cmdKey  = initCmd || 'replSetInitiate';\n" 
"var timeout = timeout || 30000;\n" 
"cmd[cmdKey] = config;\n" 
"printjson(cmd);\n" 
"\n" 
"jsTest.attempt({context:this, timeout: timeout, desc: \"Initiate replica set\"}, function() {\n" 
"var result = master.runCommand(cmd);\n" 
"printjson(result);\n" 
"return result['ok'] == 1;\n" 
"});\n" 
"\n" 
"this.awaitSecondaryNodes();\n" 
"\n" 
"// Setup authentication if running test with authentication\n" 
"if (jsTestOptions().keyFile && !this.keyFile) {\n" 
"master = this.getMaster();\n" 
"jsTest.addAuth(master);\n" 
"jsTest.authenticateNodes(this.nodes);\n" 
"}\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.reInitiate = function() {\n" 
"var master  = this.nodes[0];\n" 
"var c = master.getDB(\"local\")['system.replset'].findOne();\n" 
"var config  = this.getReplSetConfig();\n" 
"config.version = c.version + 1;\n" 
"this.initiate( config , 'replSetReconfig' );\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getLastOpTimeWritten = function() {\n" 
"this.getMaster();\n" 
"jsTest.attempt({context : this, desc : \"awaiting oplog query\", timeout: 30000},\n" 
"function() {\n" 
"try {\n" 
"this.latest = this.liveNodes.master.getDB(\"local\")['oplog.rs'].find({}).sort({'$natural': -1}).limit(1).next()['ts'];\n" 
"}\n" 
"catch(e) {\n" 
"print(\"ReplSetTest caught exception \" + e);\n" 
"return false;\n" 
"}\n" 
"return true;\n" 
"});\n" 
"};\n" 
"\n" 
"ReplSetTest.prototype.awaitReplication = function(timeout) {\n" 
"timeout = timeout || 30000;\n" 
"\n" 
"this.getLastOpTimeWritten();\n" 
"\n" 
"var name = this.liveNodes.master.toString().substr(14); // strip \"connection to \"\n" 
"print(\"ReplSetTest awaitReplication: starting: timestamp for primary, \" +\n" 
"name + \", is \" + tojson(this.latest));\n" 
"\n" 
"jsTest.attempt({context: this, timeout: timeout, desc: \"awaiting replication\"},\n" 
"function() {\n" 
"try {\n" 
"print(\"ReplSetTest awaitReplication: checking secondaries against timestamp \" +\n" 
"tojson(this.latest));\n" 
"var secondaryCount = 0;\n" 
"for (var i=0; i<this.liveNodes.slaves.length; i++) {\n" 
"var slave = this.liveNodes.slaves[i];\n" 
"\n" 
"// Continue if we're connected to an arbiter\n" 
"if (res = slave.getDB(\"admin\").runCommand({replSetGetStatus: 1})) {\n" 
"if (res.myState == 7) {\n" 
"continue;\n" 
"}\n" 
"}\n" 
"\n" 
"++secondaryCount;\n" 
"var name = slave.toString().substr(14); // strip \"connection to \"\n" 
"print(\"ReplSetTest awaitReplication: checking secondary #\" +\n" 
"secondaryCount + \": \" + name);\n" 
"slave.getDB(\"admin\").getMongo().setSlaveOk();\n" 
"var log = slave.getDB(\"local\")['oplog.rs'];\n" 
"if (log.find({}).sort({'$natural': -1}).limit(1).hasNext()) {\n" 
"var entry = log.find({}).sort({'$natural': -1}).limit(1).next();\n" 
"var ts = entry['ts'];\n" 
"if (this.latest.t < ts.t ||\n" 
"(this.latest.t == ts.t && this.latest.i < ts.i)) {\n" 
"this.latest = this.liveNodes.master.getDB(\"local\")['oplog.rs'].\n" 
"find({}).\n" 
"sort({'$natural': -1}).\n" 
"limit(1).\n" 
"next()['ts'];\n" 
"print(\"ReplSetTest awaitReplication: timestamp for \" + name +\n" 
"\" is newer, resetting latest to \" + tojson(this.latest));\n" 
"return false;\n" 
"}\n" 
"if (!friendlyEqual(this.latest, ts)) {\n" 
"print(\"ReplSetTest awaitReplication: timestamp for secondary #\" +\n" 
"secondaryCount + \", \" + name + \", is \" + tojson(ts) +\n" 
"\" but latest is \" + tojson(this.latest));\n" 
"print(\"ReplSetTest awaitReplication: last oplog entry (of \" +\n" 
"log.count() + \") for secondary #\" + secondaryCount +\n" 
"\", \" + name + \", is \" + tojsononeline(entry));\n" 
"print(\"ReplSetTest awaitReplication: secondary #\" +\n" 
"secondaryCount + \", \" + name + \", is NOT synced\");\n" 
"return false;\n" 
"}\n" 
"print(\"ReplSetTest awaitReplication: secondary #\" +\n" 
"secondaryCount + \", \" + name + \", is synced\");\n" 
"}\n" 
"else {\n" 
"print(\"ReplSetTest awaitReplication: waiting for secondary #\" +\n" 
"secondaryCount + \", \" + name + \", to have an oplog built\");\n" 
"return false;\n" 
"}\n" 
"}\n" 
"\n" 
"print(\"ReplSetTest awaitReplication: finished: all \" + secondaryCount +\n" 
"\" secondaries synced at timestamp \" + tojson(this.latest));\n" 
"return true;\n" 
"}\n" 
"catch (e) {\n" 
"print(\"ReplSetTest awaitReplication: caught exception: \" + e);\n" 
"\n" 
"// we might have a new master now\n" 
"this.getLastOpTimeWritten();\n" 
"print(\"ReplSetTest awaitReplication: resetting: timestamp for primary \" +\n" 
"this.liveNodes.master + \" is \" + tojson(this.latest));\n" 
"return false;\n" 
"}\n" 
"});\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.getHashes = function( db ){\n" 
"this.getMaster();\n" 
"var res = {};\n" 
"res.master = this.liveNodes.master.getDB( db ).runCommand( \"dbhash\" )\n" 
"res.slaves = this.liveNodes.slaves.map( function(z){ return z.getDB( db ).runCommand( \"dbhash\" ); } )\n" 
"return res;\n" 
"}\n" 
"\n" 
"/**\n" 
"* Starts up a server.  Options are saved by default for subsequent starts.\n" 
"*\n" 
"*\n" 
"* Options { remember : true } re-applies the saved options from a prior start.\n" 
"* Options { noRemember : true } ignores the current properties.\n" 
"* Options { appendOptions : true } appends the current options to those remembered.\n" 
"* Options { startClean : true } clears the data directory before starting.\n" 
"*\n" 
"* @param {int|conn|[int|conn]} n array or single server number (0, 1, 2, ...) or conn\n" 
"* @param {object} [options]\n" 
"* @param {boolean} [restart] If false, the data directory will be cleared\n" 
"*   before the server starts.  Default: false.\n" 
"*\n" 
"*/\n" 
"ReplSetTest.prototype.start = function( n , options , restart , wait ){\n" 
"\n" 
"if( n.length ){\n" 
"\n" 
"var nodes = n\n" 
"var started = []\n" 
"\n" 
"for( var i = 0; i < nodes.length; i++ ){\n" 
"if( this.start( nodes[i], Object.merge({}, options), restart, wait ) ){\n" 
"started.push( nodes[i] )\n" 
"}\n" 
"}\n" 
"\n" 
"return started\n" 
"\n" 
"}\n" 
"\n" 
"print( \"ReplSetTest n is : \" + n )\n" 
"\n" 
"defaults = { useHostName : this.useHostName,\n" 
"oplogSize : this.oplogSize,\n" 
"keyFile : this.keyFile,\n" 
"port : this.getPort( n ),\n" 
"noprealloc : \"\",\n" 
"smallfiles : \"\",\n" 
"rest : \"\",\n" 
"replSet : this.useSeedList ? this.getURL() : this.name,\n" 
"dbpath : \"$set-$node\" }\n" 
"\n" 
"defaults = Object.merge( defaults, ReplSetTest.nodeOptions || {} )\n" 
"\n" 
"// TODO : should we do something special if we don't currently know about this node?\n" 
"n = this.getNodeId( n )\n" 
"\n" 
"//\n" 
"// Note : this replaces the binVersion of the shared startSet() options the first time\n" 
"// through, so the full set is guaranteed to have different versions if size > 1.  If using\n" 
"// start() independently, independent version choices will be made\n" 
"//\n" 
"if( options && options.binVersion ){\n" 
"options.binVersion =\n" 
"MongoRunner.versionIterator( options.binVersion )\n" 
"}\n" 
"\n" 
"options = Object.merge( defaults, options )\n" 
"options = Object.merge( options, this.nodeOptions[ \"n\" + n ] )\n" 
"\n" 
"options.restart = restart\n" 
"\n" 
"var pathOpts = { node : n, set : this.name }\n" 
"options.pathOpts = Object.merge( options.pathOpts || {}, pathOpts )\n" 
"\n" 
"if( tojson(options) != tojson({}) )\n" 
"printjson(options)\n" 
"\n" 
"// make sure to call getPath, otherwise folders wont be cleaned\n" 
"this.getPath(n);\n" 
"\n" 
"print(\"ReplSetTest \" + (restart ? \"(Re)\" : \"\") + \"Starting....\");\n" 
"\n" 
"var rval = this.nodes[n] = MongoRunner.runMongod( options )\n" 
"\n" 
"if( ! rval ) return rval\n" 
"\n" 
"// Add replica set specific attributes\n" 
"this.nodes[n].nodeId = n\n" 
"\n" 
"printjson( this.nodes )\n" 
"\n" 
"wait = wait || false\n" 
"if( ! wait.toFixed ){\n" 
"if( wait ) wait = 0\n" 
"else wait = -1\n" 
"}\n" 
"\n" 
"if( wait < 0 ) return rval\n" 
"\n" 
"// Wait for startup\n" 
"this.waitForHealth( rval, this.UP, wait )\n" 
"\n" 
"return rval\n" 
"\n" 
"}\n" 
"\n" 
"\n" 
"/**\n" 
"* Restarts a db without clearing the data directory by default.  If the server is not\n" 
"* stopped first, this function will not work.\n" 
"*\n" 
"* Option { startClean : true } forces clearing the data directory.\n" 
"* Option { auth : Object } object that contains the auth details for admin credentials.\n" 
"*   Should contain the fields 'user' and 'pwd'\n" 
"*\n" 
"* @param {int|conn|[int|conn]} n array or single server number (0, 1, 2, ...) or conn\n" 
"*/\n" 
"ReplSetTest.prototype.restart = function( n , options, signal, wait ){\n" 
"// Can specify wait as third parameter, if using default signal\n" 
"if( signal == true || signal == false ){\n" 
"wait = signal\n" 
"signal = undefined\n" 
"}\n" 
"\n" 
"this.stop( n, signal, wait && wait.toFixed ? wait : true, options )\n" 
"started = this.start( n , options , true, wait );\n" 
"\n" 
"if (jsTestOptions().keyFile && !this.keyFile) {\n" 
"if (started.length) {\n" 
"// if n was an array of conns, start will return an array of connections\n" 
"for (var i = 0; i < started.length; i++) {\n" 
"jsTest.authenticate(started[i]);\n" 
"}\n" 
"} else {\n" 
"jsTest.authenticate(started);\n" 
"}\n" 
"}\n" 
"return started;\n" 
"}\n" 
"\n" 
"ReplSetTest.prototype.stopMaster = function( signal , wait, opts ) {\n" 
"var master = this.getMaster();\n" 
"var master_id = this.getNodeId( master );\n" 
"return this.stop( master_id , signal , wait, opts );\n" 
"}\n" 
"\n" 
"/**\n" 
"* Stops a particular node or nodes, specified by conn or id\n" 
"*\n" 
"* @param {number} n the index of the replica set member to stop\n" 
"* @param {number} signal the signal number to use for killing\n" 
"* @param {boolean} wait\n" 
"* @param {Object} opts @see MongoRunner.stopMongod\n" 
"*/\n" 
"ReplSetTest.prototype.stop = function( n , signal, wait /* wait for stop */, opts ){\n" 
"\n" 
"// Flatten array of nodes to stop\n" 
"if( n.length ){\n" 
"nodes = n\n" 
"\n" 
"var stopped = []\n" 
"for( var i = 0; i < nodes.length; i++ ){\n" 
"if( this.stop( nodes[i], signal, wait, opts ) )\n" 
"stopped.push( nodes[i] )\n" 
"}\n" 
"\n" 
"return stopped\n" 
"}\n" 
"\n" 
"// Can specify wait as second parameter, if using default signal\n" 
"if( signal == true || signal == false ){\n" 
"wait = signal\n" 
"signal = undefined\n" 
"}\n" 
"\n" 
"wait = wait || false\n" 
"if( ! wait.toFixed ){\n" 
"if( wait ) wait = 0\n" 
"else wait = -1\n" 
"}\n" 
"\n" 
"var port = this.getPort( n );\n" 
"print('ReplSetTest stop *** Shutting down mongod in port ' + port + ' ***');\n" 
"var ret = MongoRunner.stopMongod( port , signal, opts );\n" 
"\n" 
"if( ! ret || wait < 0 ) return ret\n" 
"\n" 
"// Wait for shutdown\n" 
"this.waitForHealth( n, this.DOWN, wait )\n" 
"\n" 
"return true\n" 
"}\n" 
"\n" 
"/**\n" 
"* Kill all members of this replica set.\n" 
"*\n" 
"* @param {number} signal The signal number to use for killing the members\n" 
"* @param {boolean} forRestart will not cleanup data directory or teardown\n" 
"*   bridges if set to true.\n" 
"* @param {Object} opts @see MongoRunner.stopMongod\n" 
"*/\n" 
"ReplSetTest.prototype.stopSet = function( signal , forRestart, opts ) {\n" 
"for(var i=0; i < this.ports.length; i++) {\n" 
"this.stop( i, signal, false, opts );\n" 
"}\n" 
"if ( forRestart ) { return; }\n" 
"if ( this._alldbpaths ){\n" 
"print(\"ReplSetTest stopSet deleting all dbpaths\");\n" 
"for( i=0; i<this._alldbpaths.length; i++ ){\n" 
"resetDbpath( this._alldbpaths[i] );\n" 
"}\n" 
"}\n" 
"if ( this.bridges ) {\n" 
"var mybridgevec;\n" 
"while (mybridgevec = this.bridges.pop()) {\n" 
"var mybridge;\n" 
"while (mybridge = mybridgevec.pop()) {\n" 
"mybridge.stop();\n" 
"}\n" 
"}\n" 
"}\n" 
"\n" 
"print('ReplSetTest stopSet *** Shut down repl set - test worked ****' )\n" 
"};\n" 
"\n" 
"\n" 
"/**\n" 
"* Waits until there is a master node\n" 
"*/\n" 
"ReplSetTest.prototype.waitForMaster = function( timeout ){\n" 
"\n" 
"var master = undefined\n" 
"\n" 
"jsTest.attempt({context: this, timeout: timeout, desc: \"waiting for master\"}, function() {\n" 
"return ( master = this.getMaster() )\n" 
"});\n" 
"\n" 
"return master\n" 
"}\n" 
"\n" 
"\n" 
"/**\n" 
"* Wait for a health indicator to go to a particular state or states.\n" 
"*\n" 
"* @param node is a single node or list of nodes, by id or conn\n" 
"* @param state is a single state or list of states\n" 
"*\n" 
"*/\n" 
"ReplSetTest.prototype.waitForHealth = function( node, state, timeout ){\n" 
"this.waitForIndicator( node, state, \"health\", timeout )\n" 
"}\n" 
"\n" 
"/**\n" 
"* Wait for a state indicator to go to a particular state or states.\n" 
"*\n" 
"* @param node is a single node or list of nodes, by id or conn\n" 
"* @param state is a single state or list of states\n" 
"*\n" 
"*/\n" 
"ReplSetTest.prototype.waitForState = function( node, state, timeout ){\n" 
"this.waitForIndicator( node, state, \"state\", timeout )\n" 
"}\n" 
"\n" 
"/**\n" 
"* Wait for a rs indicator to go to a particular state or states.\n" 
"*\n" 
"* @param node is a single node or list of nodes, by id or conn\n" 
"* @param states is a single state or list of states\n" 
"* @param ind is the indicator specified\n" 
"*\n" 
"*/\n" 
"ReplSetTest.prototype.waitForIndicator = function( node, states, ind, timeout ){\n" 
"\n" 
"if( node.length ){\n" 
"\n" 
"var nodes = node\n" 
"for( var i = 0; i < nodes.length; i++ ){\n" 
"if( states.length )\n" 
"this.waitForIndicator( nodes[i], states[i], ind, timeout )\n" 
"else\n" 
"this.waitForIndicator( nodes[i], states, ind, timeout )\n" 
"}\n" 
"\n" 
"return;\n" 
"}\n" 
"\n" 
"timeout = timeout || 30000;\n" 
"\n" 
"if( ! node.getDB ){\n" 
"node = this.nodes[node]\n" 
"}\n" 
"\n" 
"if( ! states.length ) states = [ states ]\n" 
"\n" 
"print( \"ReplSetTest waitForIndicator \" + ind + \" on \" + node )\n" 
"printjson( states )\n" 
"print( \"ReplSetTest waitForIndicator from node \" + node )\n" 
"\n" 
"var lastTime = null\n" 
"var currTime = new Date().getTime()\n" 
"var status = undefined\n" 
"\n" 
"jsTest.attempt({context: this, timeout: timeout, desc: \"waiting for state indicator \" + ind + \" for \" + timeout + \"ms\" }, function() {\n" 
"\n" 
"status = this.status()\n" 
"\n" 
"var printStatus = false\n" 
"if( lastTime == null || ( currTime = new Date().getTime() ) - (1000 * 5) > lastTime ){\n" 
"if( lastTime == null ) print( \"ReplSetTest waitForIndicator Initial status ( timeout : \" + timeout + \" ) :\" )\n" 
"printjson( status )\n" 
"lastTime = new Date().getTime()\n" 
"printStatus = true\n" 
"}\n" 
"\n" 
"if (typeof status.members == 'undefined') {\n" 
"return false;\n" 
"}\n" 
"\n" 
"for( var i = 0; i < status.members.length; i++ ){\n" 
"if( printStatus ) print( \"Status for : \" + status.members[i].name + \", checking \" + node.host + \"/\" + node.name )\n" 
"if( status.members[i].name == node.host || status.members[i].name == node.name ){\n" 
"for( var j = 0; j < states.length; j++ ){\n" 
"if( printStatus ) print( \"Status \" + \" : \" + status.members[i][ind] + \"  target state : \" + states[j] )\n" 
"if( status.members[i][ind] == states[j] ) return true;\n" 
"}\n" 
"}\n" 
"}\n" 
"\n" 
"return false\n" 
"\n" 
"});\n" 
"\n" 
"print( \"ReplSetTest waitForIndicator final status:\" )\n" 
"printjson( status )\n" 
"\n" 
"}\n" 
"\n" 
"ReplSetTest.Health = {}\n" 
"ReplSetTest.Health.UP = 1\n" 
"ReplSetTest.Health.DOWN = 0\n" 
"\n" 
"ReplSetTest.State = {}\n" 
"ReplSetTest.State.PRIMARY = 1\n" 
"ReplSetTest.State.SECONDARY = 2\n" 
"ReplSetTest.State.RECOVERING = 3\n" 
"ReplSetTest.State.ARBITER = 7\n" 
"\n" 
"/**\n" 
"* Overflows a replica set secondary or secondaries, specified by id or conn.\n" 
"*/\n" 
"ReplSetTest.prototype.overflow = function( secondaries ){\n" 
"\n" 
"// Create a new collection to overflow, allow secondaries to replicate\n" 
"var master = this.getMaster()\n" 
"var overflowColl = master.getCollection( \"_overflow.coll\" )\n" 
"overflowColl.insert({ replicated : \"value\" })\n" 
"this.awaitReplication()\n" 
"\n" 
"this.stop( secondaries, undefined, 5 * 60 * 1000 )\n" 
"\n" 
"var count = master.getDB(\"local\").oplog.rs.count();\n" 
"var prevCount = -1;\n" 
"\n" 
"// Keep inserting till we hit our capped coll limits\n" 
"while (count != prevCount) {\n" 
"\n" 
"print(\"ReplSetTest overflow inserting 10000\");\n" 
"\n" 
"for (var i = 0; i < 10000; i++) {\n" 
"overflowColl.insert({ overflow : \"value\" });\n" 
"}\n" 
"prevCount = count;\n" 
"this.awaitReplication();\n" 
"\n" 
"count = master.getDB(\"local\").oplog.rs.count();\n" 
"\n" 
"print( \"ReplSetTest overflow count : \" + count + \" prev : \" + prevCount );\n" 
"\n" 
"}\n" 
"\n" 
"// Restart all our secondaries and wait for recovery state\n" 
"this.start( secondaries, { remember : true }, true, true )\n" 
"this.waitForState( secondaries, this.RECOVERING, 5 * 60 * 1000 )\n" 
"\n" 
"}\n" 
"\n" 
"\n" 
"\n" 
"\n" 
"/**\n" 
"* Bridging allows you to test network partitioning.  For example, you can set\n" 
"* up a replica set, run bridge(), then kill the connection between any two\n" 
"* nodes x and y with partition(x, y).\n" 
"*\n" 
"* Once you have called bridging, you cannot reconfigure the replica set.\n" 
"*/\n" 
"ReplSetTest.prototype.bridge = function( opts ) {\n" 
"if (this.bridges) {\n" 
"print(\"ReplSetTest bridge bridges have already been created!\");\n" 
"return;\n" 
"}\n" 
"\n" 
"var n = this.nodes.length;\n" 
"\n" 
"// create bridges\n" 
"this.bridges = [];\n" 
"for (var i=0; i<n; i++) {\n" 
"var nodeBridges = [];\n" 
"for (var j=0; j<n; j++) {\n" 
"if (i == j) {\n" 
"continue;\n" 
"}\n" 
"nodeBridges[j] = new ReplSetBridge(this, i, j);\n" 
"}\n" 
"this.bridges.push(nodeBridges);\n" 
"}\n" 
"print(\"ReplSetTest bridge bridges: \" + this.bridges);\n" 
"\n" 
"// restart everyone independently\n" 
"this.stopSet(null, true, opts );\n" 
"for (var i=0; i<n; i++) {\n" 
"this.restart(i, {noReplSet : true});\n" 
"}\n" 
"\n" 
"// create new configs\n" 
"for (var i=0; i<n; i++) {\n" 
"config = this.nodes[i].getDB(\"local\").system.replset.findOne();\n" 
"\n" 
"if (!config) {\n" 
"print(\"ReplSetTest bridge couldn't find config for \"+this.nodes[i]);\n" 
"printjson(this.nodes[i].getDB(\"local\").system.namespaces.find().toArray());\n" 
"assert(false);\n" 
"}\n" 
"\n" 
"var updateMod = {\"$set\" : {}};\n" 
"for (var j = 0; j<config.members.length; j++) {\n" 
"if (config.members[j].host == this.host+\":\"+this.ports[i]) {\n" 
"continue;\n" 
"}\n" 
"\n" 
"updateMod['$set'][\"members.\"+j+\".host\"] = this.bridges[i][j].host;\n" 
"}\n" 
"print(\"ReplSetTest bridge for node \" + i + \":\");\n" 
"printjson(updateMod);\n" 
"this.nodes[i].getDB(\"local\").system.replset.update({},updateMod);\n" 
"}\n" 
"\n" 
"this.stopSet( null, true, opts );\n" 
"\n" 
"// start set\n" 
"for (var i=0; i<n; i++) {\n" 
"this.restart(i);\n" 
"}\n" 
"\n" 
"return this.getMaster();\n" 
"};\n" 
"\n" 
"/**\n" 
"* This kills the bridge between two nodes.  As parameters, specify the from and\n" 
"* to node numbers.\n" 
"*\n" 
"* For example, with a three-member replica set, we'd have nodes 0, 1, and 2,\n" 
"* with the following bridges: 0->1, 0->2, 1->0, 1->2, 2->0, 2->1.  We can kill\n" 
"* the connection between nodes 0 and 2 by calling replTest.partition(0,2) or\n" 
"* replTest.partition(2,0) (either way is identical). Then the replica set would\n" 
"* have the following bridges: 0->1, 1->0, 1->2, 2->1.\n" 
"*/\n" 
"ReplSetTest.prototype.partition = function(from, to) {\n" 
"this.bridges[from][to].stop();\n" 
"this.bridges[to][from].stop();\n" 
"};\n" 
"\n" 
"/**\n" 
"* This reverses a partition created by partition() above.\n" 
"*/\n" 
"ReplSetTest.prototype.unPartition = function(from, to) {\n" 
"this.bridges[from][to].start();\n" 
"this.bridges[to][from].start();\n" 
"};\n" 
;
extern const JSFile replsettest;
const JSFile replsettest = { "src/mongo/shell/replsettest.js", _jscode_raw_replsettest };
const StringData _jscode_raw_replsetbridge = 
"ReplSetBridge = function(rst, from, to) {\n" 
"var n = rst.nodes.length;\n" 
"\n" 
"var startPort = rst.startPort+n;\n" 
"this.port = (startPort+(from*n+to));\n" 
"this.host = rst.host+\":\"+this.port;\n" 
"\n" 
"this.dest = rst.host+\":\"+rst.ports[to];\n" 
"this.start();\n" 
"};\n" 
"\n" 
"ReplSetBridge.prototype.start = function() {\n" 
"var args = [\"mongobridge\", \"--port\", this.port, \"--dest\", this.dest];\n" 
"print(\"ReplSetBridge starting: \"+tojson(args));\n" 
"this.bridge = startMongoProgram.apply( null , args );\n" 
"print(\"ReplSetBridge started \" + this.bridge);\n" 
"};\n" 
"\n" 
"ReplSetBridge.prototype.stop = function() {\n" 
"print(\"ReplSetBridge stopping: \" + this.port);\n" 
"stopMongod(this.port, 9);\n" 
"};\n" 
"\n" 
"ReplSetBridge.prototype.toString = function() {\n" 
"return this.host+\" -> \"+this.dest;\n" 
"};\n" 
;
extern const JSFile replsetbridge;
const JSFile replsetbridge = { "src/mongo/shell/replsetbridge.js", _jscode_raw_replsetbridge };
} // namespace JSFiles
} // namespace mongo
